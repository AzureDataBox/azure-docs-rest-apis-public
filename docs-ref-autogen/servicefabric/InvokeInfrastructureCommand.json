{
  "swagger": "2.0",
  "info": {
    "version": "6.0.0.1",
    "title": "Service Fabric Client APIs",
    "description": "Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services."
  },
  "host": "localhost:19080",
  "schemes": [
    "http",
    "https"
  ],
  "paths": {},
  "definitions": {
    "AadMetadata": {
      "type": "object",
      "description": "Azure Active Directory metadata used for secured connection to cluster.",
      "properties": {
        "authority": {
          "type": "string",
          "description": "The AAD authority url."
        },
        "client": {
          "type": "string",
          "description": "The AAD client application Id."
        },
        "cluster": {
          "type": "string",
          "description": "The AAD cluster application Id."
        },
        "login": {
          "type": "string",
          "description": "The AAD login url."
        },
        "redirect": {
          "type": "string",
          "description": "The client application redirect address."
        },
        "tenant": {
          "type": "string",
          "description": "The AAD tenant Id."
        }
      }
    },
    "AadMetadataObject": {
      "type": "object",
      "description": "Azure Active Directory metadata object used for secured connection to cluster.",
      "properties": {
        "type": {
          "type": "string",
          "description": "The client authentication method."
        },
        "metadata": {
          "$ref": "#/definitions/AadMetadata"
        }
      }
    },
    "ApplicationDefinitionKind": {
      "type": "string",
      "description": "The mechanism used to define a Service Fabric application. Possible values are.\n\n  - Invalid - Indicates the application definition kind is invalid. All Service Fabric enumerations have the invalid type. The value is 65535.\n  - ServiceFabricApplicationDescription - Indicates the application is defined by a Service Fabric application description. The value is 0.\n  - Compose - Indicates the application is defined by compose file(s). The value is 1.\n",
      "enum": [
        "Invalid",
        "ServiceFabricApplicationDescription",
        "Compose"
      ]
    },
    "ApplicationHealth": {
      "description": "Represents the health of the application. Contains the application aggregated health state and the service and deployed application health states.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "ApplicationHealth",
          "properties": {
            "Name": {
              "$ref": "#/definitions/ApplicationName"
            },
            "ServiceHealthStates": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ServiceHealthState"
              },
              "description": "Service health states as found in the health store."
            },
            "DeployedApplicationHealthStates": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/DeployedApplicationHealthState"
              },
              "description": "Deployed application health states as found in the health store."
            }
          }
        }
      ]
    },
    "ApplicationHealthEvaluation": {
      "x-ms-discriminator-value": "Application",
      "description": "Represents health evaluation for an application, containing information about the data and the algorithm used by the health store to evaluate health.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ApplicationHealthEvaluation",
          "properties": {
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ApplicationHealthPolicies": {
      "type": "object",
      "description": "Defines the application health policy map used to evaluate the health of an application or one of its children entities.\n",
      "properties": {
        "ApplicationHealthPolicyMap": {
          "$ref": "#/definitions/ApplicationHealthPolicyMap"
        }
      }
    },
    "ApplicationHealthPolicy": {
      "type": "object",
      "description": "Defines a health policy used to evaluate the health of an application or one of its children entities.\n",
      "properties": {
        "ConsiderWarningAsError": {
          "type": "boolean",
          "description": "Indicates whether warnings are treated with the same severity as errors.",
          "default": false
        },
        "MaxPercentUnhealthyDeployedApplications": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.\nThe percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.\nThis is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.\nThe computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.\n",
          "default": 0
        },
        "DefaultServiceTypeHealthPolicy": {
          "$ref": "#/definitions/ServiceTypeHealthPolicy"
        },
        "ServiceTypeHealthPolicyMap": {
          "$ref": "#/definitions/ServiceTypeHealthPolicyMap"
        }
      }
    },
    "ApplicationHealthPolicyMap": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ApplicationHealthPolicyMapItem"
      },
      "description": "Defines a map that contains specific application health policies for different applications.\nEach entry specifies as key the application name and as value an ApplicationHealthPolicy used to evaluate the application health.\nIf an application is not specified in the map, the application health evaluation uses the ApplicationHealthPolicy found in its application manifest or the default application health policy (if no health policy is defined in the manifest).\nThe map is empty by default.\n"
    },
    "ApplicationHealthPolicyMapItem": {
      "type": "object",
      "description": "Defines an item in ApplicationHealthPolicyMap.\n",
      "required": [
        "Key",
        "Value"
      ],
      "properties": {
        "Key": {
          "$ref": "#/definitions/ApplicationName"
        },
        "Value": {
          "$ref": "#/definitions/ApplicationHealthPolicy"
        }
      }
    },
    "ApplicationHealthState": {
      "description": "Represents the health state of an application, which contains the application identifier and the aggregated health state.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "ApplicationHealthState",
          "properties": {
            "Name": {
              "$ref": "#/definitions/ApplicationName"
            }
          }
        }
      ]
    },
    "ApplicationHealthStateChunk": {
      "description": "Represents the health state chunk of a application.\nThe application health state chunk contains the application name, its aggregated health state and any children services and deployed applications that respect the filters in cluster health chunk query description.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "ApplicationHealthStateChunk",
          "properties": {
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            },
            "ApplicationTypeName": {
              "$ref": "#/definitions/ApplicationTypeName"
            },
            "ServiceHealthStateChunks": {
              "$ref": "#/definitions/ServiceHealthStateChunkList"
            },
            "DeployedApplicationHealthStateChunks": {
              "$ref": "#/definitions/DeployedApplicationHealthStateChunkList"
            }
          }
        }
      ]
    },
    "ApplicationHealthStateChunkList": {
      "type": "object",
      "description": "The list of application health state chunks in the cluster that respect the input filters in the chunk query. Returned by get cluster health state chunks query.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunkList"
        },
        {
          "type": "object",
          "description": "ApplicationHealthStateChunkList",
          "properties": {
            "Items": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ApplicationHealthStateChunk"
              },
              "description": "The list of application health state chunks that respect the input filters in the chunk query.\n"
            }
          }
        }
      ]
    },
    "ApplicationHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a application should be included in the cluster health chunk.\nOne filter can match zero, one or multiple applications, depending on its properties.\n",
      "properties": {
        "ApplicationNameFilter": {
          "type": "string",
          "description": "The name of the application that matches the filter, as a fabric uri. The filter is applied only to the specified application, if it exists.\nIf the application doesn't exist, no application is returned in the cluster health chunk based on this filter.\nIf the application exists, it is included in the cluster health chunk if it respects the other filter properties.\nIf not specified, all applications are matched against the other filter members, like health state filter.\n"
        },
        "ApplicationTypeNameFilter": {
          "type": "string",
          "description": "The name of the application type that matches the filter.\nIf specified, the filter is applied only to applications of the selected application type, if any exists.\nIf no applications of the specified application type exists, no application is returned in the cluster health chunk based on this filter.\nEach application of the specified application type is included in the cluster health chunk if it respects the other filter properties.\nIf not specified, all applications are matched against the other filter members, like health state filter.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the applications. It allows selecting applications if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only applications that match the filter are returned. All applications are used to evaluate the cluster aggregated health state.\nIf not specified, default value is None, unless the application name or the application type name are specified. If the filter has default value and application name is specified, the matching application is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches applications with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        },
        "ServiceFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which services to be included in the returned cluster health chunk as children of the application. The services are returned only if the parent application matches a filter.\nIf the list is empty, no services are returned. All the services are used to evaluate the parent application aggregated health state, regardless of the input filters.\nThe application filter may specify multiple service filters.\nFor example, it can specify a filter to return all services with health state Error and another filter to always include a service identified by its service name.\n"
        },
        "DeployedApplicationFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DeployedApplicationHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which deployed applications to be included in the returned cluster health chunk as children of the application. The deployed applications are returned only if the parent application matches a filter.\nIf the list is empty, no deployed applications are returned. All the deployed applications are used to evaluate the parent application aggregated health state, regardless of the input filters.\nThe application filter may specify multiple deployed application filters.\nFor example, it can specify a filter to return all deployed applications with health state Error and another filter to always include a deployed application on a specified node.\n"
        }
      }
    },
    "ApplicationId": {
      "type": "string",
      "description": "The identity of the application. This is an encoded representation of the application name. This is used in the REST APIs to identify the application resource. \n\nStarting in version 6.0, hierarchical names are delimited with the \"~\" character. For example, if the application name is \"fabric://myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions.\n"
    },
    "ApplicationInfo": {
      "type": "object",
      "description": "Information about a Service Fabric application.",
      "properties": {
        "Id": {
          "$ref": "#/definitions/ApplicationId"
        },
        "Name": {
          "$ref": "#/definitions/ApplicationName"
        },
        "TypeName": {
          "$ref": "#/definitions/ApplicationTypeName"
        },
        "TypeVersion": {
          "$ref": "#/definitions/ApplicationTypeVersion"
        },
        "Status": {
          "$ref": "#/definitions/ApplicationStatus"
        },
        "Parameters": {
          "$ref": "#/definitions/ApplicationParameterList"
        },
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "ApplicationDefinitionKind": {
          "$ref": "#/definitions/ApplicationDefinitionKind"
        }
      }
    },
    "ApplicationLoadInfo": {
      "type": "object",
      "description": "Load Information about a Service Fabric application.",
      "properties": {
        "Id": {
          "$ref": "#/definitions/ApplicationId"
        },
        "MinimumNodes": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum number of nodes for this application.\nIt is the number of nodes where Service Fabric will reserve Capacity in the cluster which equals to ReservedLoad * MinimumNodes for this Application instance.\nFor applications that do not have application capacity defined this value will be zero.\n"
        },
        "MaximumNodes": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of nodes where this application can be instantiated.\nIt is the number of nodes this application is allowed to span.\nFor applications that do not have application capacity defined this value will be zero.\n"
        },
        "NodeCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of nodes on which this application is instantiated.\nFor applications that do not have application capacity defined this value will be zero.\n"
        },
        "ApplicationLoadMetricInformation": {
          "$ref": "#/definitions/ApplicationMetricDescriptionList"
        }
      }
    },
    "ApplicationName": {
      "type": "string",
      "description": "The name of the application, including the 'fabric:' URI scheme."
    },
    "ApplicationNameInfo": {
      "type": "object",
      "description": "Information about the application name.",
      "properties": {
        "Id": {
          "$ref": "#/definitions/ApplicationId"
        },
        "Name": {
          "$ref": "#/definitions/ApplicationName"
        }
      }
    },
    "ApplicationParameter": {
      "type": "object",
      "description": "Describes an application parameter override to be applied when creating or upgrading an application.",
      "required": [
        "Key",
        "Value"
      ],
      "properties": {
        "Key": {
          "type": "string",
          "description": "The name of the parameter."
        },
        "Value": {
          "type": "string",
          "description": "The value of the parameter."
        }
      }
    },
    "ApplicationParameterList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ApplicationParameter"
      },
      "description": "List of application parameters with overridden values from their default values specified in the application manifest."
    },
    "ApplicationsHealthEvaluation": {
      "x-ms-discriminator-value": "Applications",
      "description": "Represents health evaluation for applications, containing health evaluations for each unhealthy application that impacted current aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ApplicationsHealthEvaluation",
          "properties": {
            "MaxPercentUnhealthyApplications": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy applications from the ClusterHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of applications from the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ApplicationStatus": {
      "type": "string",
      "description": "The status of the application. Possible values are.\n\n  - Invalid - Indicates the application status is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Ready - Indicates the application status is ready. The value is 1.\n  - Upgrading - Indicates the application status is upgrading. The value is 2.\n  - Creating - Indicates the application status is creating. The value is 3.\n  - Deleting - Indicates the application status is deleting. The value is 4.\n  - Failed - Indicates the creation or deletion of application was terminated due to persistent failures. Another create/delete request can be accepted to resume a failed application. The value is 5.\n",
      "enum": [
        "Invalid",
        "Ready",
        "Upgrading",
        "Creating",
        "Deleting",
        "Failed"
      ]
    },
    "ApplicationTypeApplicationsHealthEvaluation": {
      "x-ms-discriminator-value": "ApplicationTypeApplications",
      "description": "Represents health evaluation for applications of a particular application type. The application type applications evaluation can be returned when cluster health evaluation returns unhealthy aggregated health state, either Error or Warning. It contains health evaluations for each unhealthy application of the included application type that impacted current aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ApplicationTypeApplicationsHealthEvaluation",
          "properties": {
            "ApplicationTypeName": {
              "$ref": "#/definitions/ApplicationTypeName"
            },
            "MaxPercentUnhealthyApplications": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy applications for the application type, specified as an entry in ApplicationTypeHealthPolicyMap."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of applications of the application type found in the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ApplicationTypeDefinitionKind": {
      "type": "string",
      "description": "The mechanism used to define a Service Fabric application type. Possible values are.\n\n  - Invalid - Indicates the application type definition kind is invalid. All Service Fabric enumerations have the invalid type. The value is 0.\n  - ServiceFabricApplicationPackage - Indicates the application type is defined and created by a Service Fabric application package provided by the user. The value is 1.\n  - Compose - Indicates the application type is defined and created implicitly as part of a compose deployment. The value is 2.\n",
      "enum": [
        "Invalid",
        "ServiceFabricApplicationPackage",
        "Compose"
      ]
    },
    "ApplicationTypeHealthPolicyMap": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ApplicationTypeHealthPolicyMapItem"
      },
      "description": "Defines a map with max percentage unhealthy applications for specific application types.\nEach entry specifies as key the application type name and as value an integer that represents the MaxPercentUnhealthyApplications percentage used to evaluate the applications of the specified application type.\n\nThe application type health policy map can be used during cluster health evaluation to describe special application types.\nThe application types included in the map are evaluated against the percentage specified in the map, and not with the global MaxPercentUnhealthyApplications defined in the cluster health policy.\nThe applications of application types specified in the map are not counted against the global pool of applications.\nFor example, if some applications of a type are critical, the cluster administrator can add an entry to the map for that application type\nand assign it a value of 0% (that is, do not tolerate any failures).\nAll other applications can be evaluated with MaxPercentUnhealthyApplications set to 20% to tolerate some failures out of the thousands of application instances.\nThe application type health policy map is used only if the cluster manifest enables application type health evaluation using the configuration entry for HealthManager/EnableApplicationTypeHealthEvaluation.\n"
    },
    "ApplicationTypeHealthPolicyMapItem": {
      "type": "object",
      "description": "Defines an item in ApplicationTypeHealthPolicyMap.\n",
      "required": [
        "Key",
        "Value"
      ],
      "properties": {
        "Key": {
          "type": "string",
          "description": "The key of the application type health policy map item. This is the name of the application type."
        },
        "Value": {
          "type": "integer",
          "description": "The value of the application type health policy map item.\nThe max percent unhealthy applications allowed for the application type. Must be between zero and 100.\n"
        }
      }
    },
    "ApplicationTypeInfo": {
      "type": "object",
      "description": "Information about an application type.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/ApplicationTypeName"
        },
        "Version": {
          "$ref": "#/definitions/ApplicationTypeVersion"
        },
        "DefaultParameterList": {
          "$ref": "#/definitions/ApplicationTypeParameterList"
        },
        "Status": {
          "$ref": "#/definitions/ApplicationTypeStatus"
        },
        "StatusDetails": {
          "type": "string"
        },
        "ApplicationTypeDefinitionKind": {
          "$ref": "#/definitions/ApplicationTypeDefinitionKind"
        }
      }
    },
    "PagedApplicationTypeInfoList": {
      "type": "object",
      "description": "The list of application types that are provisioned or being provisioned in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ApplicationTypeInfo"
          }
        }
      }
    },
    "ApplicationTypeManifest": {
      "type": "object",
      "description": "Contains the manifest describing an application type registered in a Service Fabric cluster.",
      "properties": {
        "Manifest": {
          "type": "string",
          "description": "The XML manifest as a string."
        }
      }
    },
    "ApplicationTypeName": {
      "type": "string",
      "description": "The application type name as defined in the application manifest."
    },
    "ApplicationTypeParameterList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ApplicationParameter"
      },
      "description": "List of application type parameters that can be overridden when creating or updating the application."
    },
    "ApplicationTypeStatus": {
      "type": "string",
      "description": "The status of the application type. Possible values are following.\n\n  - Invalid - Indicates the application type status is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Provisioning - Indicates that the application type is being provisioned in the cluster. The value is 1.\n  - Available - Indicates that the application type is fully provisioned and is available for use. An application of this type and version can be created. The value is 2.\n  - Unprovisioning - Indicates that the application type is in process of being unprovisioned from the cluster. The value is 3.\n  - Failed - Indicates that the application type provisioning failed and it is unavailable for use. The failure details can be obtained from the application type information query. The failed application type information remains in the cluster until it is unprovisioned or reprovisioned successfully. The value is 4.\n",
      "enum": [
        "Invalid",
        "Provisioning",
        "Available",
        "Unprovisioning",
        "Failed"
      ]
    },
    "ApplicationUnhealthyEvaluations": {
      "description": "List of health evaluations that resulted in the current aggregated health state.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/HealthEvaluationWrapper"
      }
    },
    "ApplicationUpgradeDescription": {
      "type": "object",
      "description": "Describes the parameters for an application upgrade. Please note that upgrade description replaces the existing application description. This means that if the parameters are not specified, the existing parameters on the applications will be overwritten with the empty parameters list. This would results in application using the default value of the parameters from the application manifest. If you do not want to change any existing parameter values, please get the application parameters first using the GetApplicationInfo query and then supply those values as Parameters in this ApplicationUpgradeDescription.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/TargetApplicationName"
        },
        "TargetApplicationTypeVersion": {
          "$ref": "#/definitions/TargetApplicationTypeVersion"
        },
        "Parameters": {
          "$ref": "#/definitions/ApplicationParameterList"
        },
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeKind"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "UpgradeReplicaSetCheckTimeoutInSeconds": {
          "$ref": "#/definitions/UpgradeReplicaSetCheckTimeout"
        },
        "ForceRestart": {
          "$ref": "#/definitions/ForceRestart"
        },
        "MonitoringPolicy": {
          "$ref": "#/definitions/MonitoringPolicyDescription"
        },
        "ApplicationHealthPolicy": {
          "$ref": "#/definitions/ApplicationHealthPolicy"
        }
      },
      "required": [
        "Name",
        "TargetApplicationTypeVersion",
        "UpgradeKind",
        "Parameters"
      ]
    },
    "ApplicationUpgradeProgressInfo": {
      "type": "object",
      "description": "Describes the parameters for an application upgrade.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/TargetApplicationName"
        },
        "TypeName": {
          "$ref": "#/definitions/ApplicationTypeName"
        },
        "TargetApplicationTypeVersion": {
          "$ref": "#/definitions/TargetApplicationTypeVersion"
        },
        "UpgradeDomains": {
          "$ref": "#/definitions/UpgradeDomainInfoList"
        },
        "UpgradeState": {
          "$ref": "#/definitions/UpgradeState"
        },
        "NextUpgradeDomain": {
          "$ref": "#/definitions/NextUpgradeDomain"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "UpgradeDescription": {
          "$ref": "#/definitions/ApplicationUpgradeDescription"
        },
        "UpgradeDurationInMilliseconds": {
          "type": "string",
          "description": "The estimated total amount of time spent processing the overall upgrade."
        },
        "UpgradeDomainDurationInMilliseconds": {
          "type": "string",
          "description": "The estimated total amount of time spent processing the current upgrade domain."
        },
        "UnhealthyEvaluations": {
          "$ref": "#/definitions/UnhealthyEvaluations"
        },
        "CurrentUpgradeDomainProgress": {
          "$ref": "#/definitions/CurrentUpgradeDomainProgressInfo"
        },
        "StartTimestampUtc": {
          "type": "string",
          "description": "The estimated UTC datetime when the upgrade started."
        },
        "FailureTimestampUtc": {
          "type": "string",
          "description": "The estimated UTC datetime when the upgrade failed and FailureAction was executed."
        },
        "FailureReason": {
          "$ref": "#/definitions/FailureReason"
        },
        "UpgradeDomainProgressAtFailure": {
          "$ref": "#/definitions/FailureUpgradeDomainProgressInfo"
        },
        "UpgradeStatusDetails": {
          "type": "string",
          "description": "Additional detailed information about the status of the pending upgrade."
        }
      }
    },
    "ByteArray": {
      "description": "Array of bytes to be sent as an integer array. Each element of array is a number between 0 and 255.",
      "type": "array",
      "items": {
        "type": "integer"
      }
    },
    "ClusterConfiguration": {
      "type": "object",
      "description": "Information about the standalone cluster configuration.",
      "properties": {
        "ClusterConfiguration": {
          "type": "string",
          "description": "The contents of the cluster configuration file."
        }
      }
    },
    "ClusterHealth": {
      "description": "Represents the health of the cluster.\nContains the cluster aggregated health state, the cluster application and node health states as well as the health events and the unhealthy evaluations.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "ClusterHealth",
          "properties": {
            "NodeHealthStates": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/NodeHealthState"
              },
              "description": "Cluster node health states as found in the health store."
            },
            "ApplicationHealthStates": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ApplicationHealthState"
              },
              "description": "Cluster application health states as found in the health store."
            }
          }
        }
      ]
    },
    "ClusterHealthChunk": {
      "description": "Represents the health chunk of the cluster.\nContains the cluster aggregated health state, and the cluster entities that respect the input filter.\n",
      "type": "object",
      "properties": {
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "NodeHealthStateChunks": {
          "$ref": "#/definitions/NodeHealthStateChunkList"
        },
        "ApplicationHealthStateChunks": {
          "$ref": "#/definitions/ApplicationHealthStateChunkList"
        }
      }
    },
    "ClusterHealthChunkQueryDescription": {
      "description": "The cluster health chunk query description, which can specify the health policies to evaluate cluster health and very expressive filters to select which cluster entities to include in response.",
      "properties": {
        "NodeFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NodeHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which nodes to be included in the returned cluster health chunk.\nIf no filters are specified, no nodes are returned. All the nodes are used to evaluate the cluster's aggregated health state, regardless of the input filters.\nThe cluster health chunk query may specify multiple node filters.\nFor example, it can specify a filter to return all nodes with health state Error and another filter to always include a node identified by its NodeName.\n"
        },
        "ApplicationFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ApplicationHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which applications to be included in the returned cluster health chunk.\nIf no filters are specified, no applications are returned. All the applications are used to evaluate the cluster's aggregated health state, regardless of the input filters.\nThe cluster health chunk query may specify multiple application filters.\nFor example, it can specify a filter to return all applications with health state Error and another filter to always include applications of a specified application type.\n"
        },
        "ClusterHealthPolicy": {
          "$ref": "#/definitions/ClusterHealthPolicy"
        },
        "ApplicationHealthPolicies": {
          "$ref": "#/definitions/ApplicationHealthPolicies"
        }
      }
    },
    "ClusterHealthPolicies": {
      "description": "Health policies to evaluate cluster health.",
      "properties": {
        "ApplicationHealthPolicyMap": {
          "$ref": "#/definitions/ApplicationHealthPolicyMap"
        },
        "ClusterHealthPolicy": {
          "$ref": "#/definitions/ClusterHealthPolicy"
        }
      }
    },
    "ClusterHealthPolicy": {
      "type": "object",
      "description": "Defines a health policy used to evaluate the health of the cluster or of a cluster node.\n",
      "properties": {
        "ConsiderWarningAsError": {
          "type": "boolean",
          "description": "Indicates whether warnings are treated with the same severity as errors.",
          "default": false
        },
        "MaxPercentUnhealthyNodes": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.\n\nThe percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.\nIf the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.\nThe percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.\nThe computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.\n\nIn large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.\n",
          "default": 0
        },
        "MaxPercentUnhealthyApplications": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.\n\nThe percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.\nIf the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.\nThis is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.\nThe computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.\n",
          "default": 0
        },
        "ApplicationTypeHealthPolicyMap": {
          "$ref": "#/definitions/ApplicationTypeHealthPolicyMap"
        }
      }
    },
    "ClusterManifest": {
      "type": "object",
      "description": "Information about the cluster manifest.",
      "properties": {
        "Manifest": {
          "type": "string",
          "description": "The contents of the cluster manifest file."
        }
      }
    },
    "ContinuationToken": {
      "type": "string",
      "description": "The continuation token parameter is used to obtain next set of results. The continuation token is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token is not included in the response."
    },
    "CurrentUpgradeDomainProgressInfo": {
      "type": "object",
      "description": "Information about the current in-progress upgrade domain.",
      "properties": {
        "DomainName": {
          "$ref": "#/definitions/UpgradeDomainName"
        },
        "NodeUpgradeProgressList": {
          "$ref": "#/definitions/NodeUpgradeProgressInfoList"
        }
      }
    },
    "CurrentUpgradeDomainDuration": {
      "type": "string",
      "description": "The estimated amount of time spent processing current Upgrade Domain. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "PT0H2M0S"
    },
    "DeactivationIntentDescription": {
      "description": "Describes the intent or reason for deactivating the node.",
      "properties": {
        "DeactivationIntent": {
          "type": "string",
          "description": "Describes the intent or reason for deactivating the node. The possible values are following.\n  - Pause - Indicates that the node should be paused. The value is 1.\n  - Restart - Indicates that the intent is for the node to be restarted after a short period of time. The value is 2.\n  - RemoveData - Indicates the intent is for the node to remove data. The value is 3.\n",
          "enum": [
            "Pause",
            "Restart",
            "RemoveData"
          ]
        }
      }
    },
    "DeltaNodesCheckHealthEvaluation": {
      "x-ms-discriminator-value": "DeltaNodesCheck",
      "description": "Represents health evaluation for delta nodes, containing health evaluations for each unhealthy node that impacted current aggregated health state.\nCan be returned during cluster upgrade when the aggregated health state of the cluster is Warning or Error.\n",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "DeltaNodesCheckHealthEvaluation",
          "properties": {
            "BaselineErrorCount": {
              "type": "integer",
              "format": "int64",
              "description": "Number of nodes with aggregated heath state Error in the health store at the beginning of the cluster upgrade."
            },
            "BaselineTotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of nodes in the health store at the beginning of the cluster upgrade."
            },
            "MaxPercentDeltaUnhealthyNodes": {
              "type": "integer",
              "description": "Maximum allowed percentage of delta unhealthy nodes from the ClusterUpgradeHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of nodes in the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "DeployedApplicationHealth": {
      "description": "Information about the health of an application deployed on a Service Fabric node.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "DeployedApplicationHealth",
          "properties": {
            "Name": {
              "$ref": "#/definitions/ApplicationName"
            },
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            },
            "DeployedServicePackageHealthStates": {
              "$ref": "#/definitions/DeployedServicePackageHealthStateList"
            }
          }
        }
      ]
    },
    "DeployedApplicationHealthEvaluation": {
      "x-ms-discriminator-value": "DeployedApplication",
      "description": "Represents health evaluation for a deployed application, containing information about the data and the algorithm used by the health store to evaluate health.\n",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "DeployedApplicationHealthEvaluation",
          "properties": {
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            },
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "DeployedApplicationHealthState": {
      "description": "Represents the health state of a deployed application, which contains the entity identifier and the aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "DeployedApplicationHealthState",
          "properties": {
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            },
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            }
          }
        }
      ]
    },
    "DeployedApplicationHealthStateChunk": {
      "description": "Represents the health state chunk of a deployed application, which contains the node where the application is deployed, the aggregated health state and any deployed service packages that respect the chunk query description filters.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "DeployedApplicationHealthStateChunk",
          "properties": {
            "NodeName": {
              "type": "string",
              "description": "The name of node where the application is deployed."
            },
            "DeployedServicePackageHealthStateChunks": {
              "$ref": "#/definitions/DeployedServicePackageHealthStateChunkList"
            }
          }
        }
      ]
    },
    "DeployedApplicationHealthStateChunkList": {
      "type": "object",
      "description": "The list of deployed application health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.\n",
      "properties": {
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DeployedApplicationHealthStateChunk"
          },
          "description": "The list of deployed application health state chunks that respect the input filters in the chunk query.\n"
        }
      }
    },
    "DeployedApplicationHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a deployed application should be included as a child of an application in the cluster health chunk.\nThe deployed applications are only returned if the parent application matches a filter specified in the cluster health chunk query description.\nOne filter can match zero, one or multiple deployed applications, depending on its properties.\n",
      "properties": {
        "NodeNameFilter": {
          "type": "string",
          "description": "The name of the node where the application is deployed in order to match the filter.\nIf specified, the filter is applied only to the application deployed on the specified node.\nIf the application is not deployed on the node with the specified name, no deployed application is returned in the cluster health chunk based on this filter.\nOtherwise, the deployed application is included in the cluster health chunk if it respects the other filter properties.\nIf not specified, all deployed applications that match the parent filters (if any) are taken into consideration and matched against the other filter members, like health state filter.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the deployed applications. It allows selecting deployed applications if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only deployed applications that match the filter are returned. All deployed applications are used to evaluate the cluster aggregated health state.\nIf not specified, default value is None, unless the node name is specified. If the filter has default value and node name is specified, the matching deployed application is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches deployed applications with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        },
        "DeployedServicePackageFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DeployedServicePackageHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which deployed service packages to be included in the returned cluster health chunk as children of the parent deployed application. The deployed service packages are returned only if the parent deployed application matches a filter.\nIf the list is empty, no deployed service packages are returned. All the deployed service packages are used to evaluate the parent deployed application aggregated health state, regardless of the input filters.\nThe deployed application filter may specify multiple deployed service package filters.\nFor example, it can specify a filter to return all deployed service packages with health state Error and another filter to always include a deployed service package on a node.\n"
        }
      }
    },
    "DeployedApplicationInfo": {
      "type": "object",
      "description": "Information about application deployed on the node.",
      "properties": {
        "Id": {
          "$ref": "#/definitions/ApplicationId"
        },
        "Name": {
          "$ref": "#/definitions/ApplicationName"
        },
        "TypeName": {
          "$ref": "#/definitions/ApplicationTypeName"
        },
        "Status": {
          "$ref": "#/definitions/DeployedApplicationStatus"
        },
        "WorkDirectory": {
          "type": "string",
          "description": "The work directory of the application on the node. The work directory can be used to store application data."
        },
        "LogDirectory": {
          "type": "string",
          "description": "The log directory of the application on the node. The log directory can be used to store application logs."
        },
        "TempDirectory": {
          "type": "string",
          "description": "The temp directory of the application on the node. The code packages belonging to the application are forked with this directory set as their temporary directory."
        }
      }
    },
    "DeployedApplicationInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/DeployedApplicationInfo"
      },
      "description": "List of deployed application information."
    },
    "DeployedApplicationsHealthEvaluation": {
      "x-ms-discriminator-value": "DeployedApplications",
      "description": "Represents health evaluation for deployed applications, containing health evaluations for each unhealthy deployed application that impacted current aggregated health state.\nCan be returned when evaluating application health and the aggregated health state is either Error or Warning.\n",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "DeployedApplicationsHealthEvaluation",
          "properties": {
            "MaxPercentUnhealthyDeployedApplications": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy deployed applications from the ApplicationHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of deployed applications of the application in the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "DeployedApplicationStatus": {
      "type": "string",
      "description": "The status of the application deployed on the node. Following are the possible values.\n\n- Invalid - Indicates that deployment status is not valid. All Service Fabric enumerations have the invalid type. The value is zero.\n- Downloading - Indicates that the package is downloading from the ImageStore. The value is 1.\n- Activating - Indicates that the package is activating. The value is 2.\n- Active - Indicates that the package is active. The value is 3.\n- Upgrading - Indicates that the package is upgrading. The value is 4.\n- Deactivating - Indicates that the package is deactivating. The value is 5.\n",
      "enum": [
        "Invalid",
        "Downloading",
        "Activating",
        "Active",
        "Upgrading",
        "Deactivating"
      ]
    },
    "DeployedServicePackageHealth": {
      "description": "Information about the health of a service package for a specific application deployed on a Service Fabric node.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "DeployedServicePackageHealth",
          "properties": {
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            },
            "ServiceManifestName": {
              "$ref": "#/definitions/ServiceManifestName"
            },
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            }
          }
        }
      ]
    },
    "DeployedServicePackageHealthEvaluation": {
      "x-ms-discriminator-value": "DeployedServicePackage",
      "description": "Represents health evaluation for a deployed service package, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "DeployedServicePackageHealthEvaluation",
          "properties": {
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            },
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            },
            "ServiceManifestName": {
              "$ref": "#/definitions/ServiceManifestName"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "DeployedServicePackageHealthState": {
      "description": "Represents the health state of a deployed service package, containing the entity identifier and the aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "DeployedServicePackageHealthState",
          "properties": {
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            },
            "ApplicationName": {
              "$ref": "#/definitions/ApplicationName"
            },
            "ServiceManifestName": {
              "$ref": "#/definitions/ServiceManifestName"
            },
            "ServicePackageActivationId": {
              "$ref": "#/definitions/ServicePackageActivationId"
            }
          }
        }
      ]
    },
    "DeployedServicePackageHealthStateChunk": {
      "description": "Represents the health state chunk of a deployed service package, which contains the service manifest name and the service package aggregated health state.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "DeployedServicePackageHealthStateChunk",
          "properties": {
            "ServiceManifestName": {
              "$ref": "#/definitions/ServiceManifestName"
            },
            "ServicePackageActivationId": {
              "$ref": "#/definitions/ServicePackageActivationId"
            }
          }
        }
      ]
    },
    "DeployedServicePackageHealthStateChunkList": {
      "type": "object",
      "description": "The list of deployed service package health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.\n",
      "properties": {
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DeployedServicePackageHealthStateChunk"
          },
          "description": "The list of deployed service package health state chunks that respect the input filters in the chunk query.\n"
        }
      }
    },
    "DeployedServicePackageHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a deployed service package should be included as a child of a deployed application in the cluster health chunk.\nThe deployed service packages are only returned if the parent entities match a filter specified in the cluster health chunk query description. The parent deployed application and its parent application must be included in the cluster health chunk.\nOne filter can match zero, one or multiple deployed service packages, depending on its properties.\n",
      "properties": {
        "ServiceManifestNameFilter": {
          "type": "string",
          "description": "The name of the service manifest which identifies the deployed service packages that matches the filter.\nIf specified, the filter is applied only to the specified deployed service packages, if any.\nIf no deployed service packages with specified manifest name exist, nothing is returned in the cluster health chunk based on this filter.\nIf any deployed service package exists, they are included in the cluster health chunk if it respects the other filter properties.\nIf not specified, all deployed service packages that match the parent filters (if any) are taken into consideration and matched against the other filter members, like health state filter.\n"
        },
        "ServicePackageActivationIdFilter": {
          "type": "string",
          "description": "The activation ID of a deployed service package that matches the filter.\nIf not specified, the filter applies to all deployed service packages that match the other parameters.\nIf specified, the filter matches only the deployed service package with the specified activation ID.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the deployed service packages. It allows selecting deployed service packages if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the parent deployed application aggregated health state.\nIf not specified, default value is None, unless the deployed service package id is specified. If the filter has default value and deployed service package id is specified, the matching deployed service package is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches deployed service packages with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        }
      }
    },
    "DeployedServicePackageHealthStateList": {
      "description": "List of health states for a service package deployed on a Service Fabric node.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DeployedServicePackageHealthState"
      }
    },
    "DeployedServicePackagesHealthEvaluation": {
      "x-ms-discriminator-value": "DeployedServicePackages",
      "description": "Represents health evaluation for deployed service packages, containing health evaluations for each unhealthy deployed service package that impacted current aggregated health state. Can be returned when evaluating deployed application health and the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "DeployedServicePackagesHealthEvaluation",
          "properties": {
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of deployed service packages of the deployed application in the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "DeployedServiceReplicaInfo": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "Information about a Service Fabric service replica deployed on a node.",
      "required": [
        "ServiceKind"
      ],
      "properties": {
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "ServiceName": {
          "$ref": "#/definitions/ServiceName"
        },
        "ServiceTypeName": {
          "$ref": "#/definitions/ServiceTypeName"
        },
        "ServiceManifestName": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "CodePackageName": {
          "$ref": "#/definitions/CodePackageName"
        },
        "PartitionId": {
          "$ref": "#/definitions/PartitionId"
        },
        "ReplicaStatus": {
          "$ref": "#/definitions/ReplicaStatus"
        },
        "Address": {
          "type": "string",
          "description": "The last address returned by the replica in Open or ChangeRole."
        },
        "ServicePackageActivationId": {
          "$ref": "#/definitions/ServicePackageActivationId"
        },
        "HostProcessId": {
          "type": "string",
          "format": "int64",
          "description": "Host process id of the process that is hosting the replica. This will be zero if the replica is down. In hyper-v containers this host process id will be from different kernel."
        }
      }
    },
    "DeployedServiceReplicaInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/DeployedServiceReplicaInfo"
      },
      "description": "List of deployed service replica information."
    },
    "DeployedStatefulServiceReplicaInfo": {
      "description": "Information about a stateful service replica deployed on a node.",
      "x-ms-discriminator-value": "Stateful",
      "allOf": [
        {
          "$ref": "#/definitions/DeployedServiceReplicaInfo"
        },
        {
          "type": "object",
          "description": "DeployedStatefulServiceReplicaInfo",
          "properties": {
            "ReplicaId": {
              "$ref": "#/definitions/ReplicaId"
            },
            "ReplicaRole": {
              "$ref": "#/definitions/ReplicaRole"
            },
            "ReconfigurationInformation": {
              "$ref": "#/definitions/ReconfigurationInformation"
            }
          }
        }
      ]
    },
    "DeployedStatelessServiceInstanceInfo": {
      "description": "Information about a stateless service instance deployed on a node.",
      "x-ms-discriminator-value": "Stateless",
      "allOf": [
        {
          "$ref": "#/definitions/DeployedServiceReplicaInfo"
        },
        {
          "type": "object",
          "description": "DeployedStatelessServiceInstanceInfo",
          "properties": {
            "InstanceId": {
              "$ref": "#/definitions/InstanceId"
            }
          }
        }
      ]
    },
    "EntityHealth": {
      "type": "object",
      "description": "Health information common to all entities in the cluster. It contains the aggregated health state, health events and unhealthy evaluation.\n",
      "properties": {
        "AggregatedHealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "HealthEvents": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HealthEvent"
          },
          "description": "The list of health events reported on the entity."
        },
        "UnhealthyEvaluations": {
          "$ref": "#/definitions/UnhealthyEvaluations"
        },
        "HealthStatistics": {
          "$ref": "#/definitions/HealthStatistics"
        }
      }
    },
    "EntityHealthState": {
      "type": "object",
      "description": "A base type for the health state of various entities in the cluster. It contains the aggregated health state.",
      "properties": {
        "AggregatedHealthState": {
          "$ref": "#/definitions/HealthState"
        }
      }
    },
    "EntityHealthStateChunk": {
      "type": "object",
      "description": "A base type for the health state chunk of various entities in the cluster. It contains the aggregated health state.",
      "properties": {
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        }
      }
    },
    "EntityHealthStateChunkList": {
      "type": "object",
      "description": "A base type for the list of health state chunks found in the cluster. It contains the total number of health states that match the input filters.",
      "properties": {
        "TotalCount": {
          "type": "integer",
          "format": "int64",
          "description": "Total number of entity health state objects that match the specified filters from the cluster health chunk query description.\n"
        }
      }
    },
    "Epoch": {
      "type": "object",
      "description": "An Epoch is a configuration number for the partition as a whole. When the configuration of the replica set changes, for example when the Primary replica changes, the operations that are replicated from the new Primary replica are said to be a new Epoch from the ones which were sent by the old Primary replica.\n",
      "properties": {
        "ConfigurationVersion": {
          "type": "string",
          "description": "The current configuration number of this Epoch. The configuration number is an increasing value that is updated whenever the configuration of this replica set changes."
        },
        "DataLossVersion": {
          "type": "string",
          "description": "The current dataloss number of this Epoch. The data loss number property is an increasing value which is updated whenever data loss is suspected, as when loss of a quorum of replicas in the replica set that includes the Primary replica."
        }
      }
    },
    "EventHealthEvaluation": {
      "x-ms-discriminator-value": "Event",
      "description": "Represents health evaluation of a HealthEvent that was reported on the entity.\nThe health evaluation is returned when evaluating health of an entity results in Error or Warning.\n",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "EventHealthEvaluation",
          "properties": {
            "ConsiderWarningAsError": {
              "type": "boolean",
              "description": "Indicates whether warnings are treated with the same severity as errors. The field is specified in the health policy used to evaluate the entity."
            },
            "UnhealthyEvent": {
              "$ref": "#/definitions/HealthEvent"
            }
          }
        }
      ]
    },
    "FabricCodeVersionInfo": {
      "type": "object",
      "description": "Information about a Service Fabric code version.",
      "properties": {
        "CodeVersion": {
          "description": "The product version of Service Fabric.",
          "type": "string"
        }
      }
    },
    "FabricCodeVersionInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/FabricCodeVersionInfo"
      },
      "description": "List of all Service Fabric code versions."
    },
    "FabricConfigVersionInfo": {
      "type": "object",
      "description": "Information about a Service Fabric config version.",
      "properties": {
        "ConfigVersion": {
          "description": "The config version of Service Fabric.",
          "type": "string"
        }
      }
    },
    "FabricConfigVersionInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/FabricConfigVersionInfo"
      },
      "description": "List of all Service Fabric config versions."
    },
    "FabricError": {
      "type": "object",
      "description": "The REST API operations for Service Fabric return standard HTTP status codes. This type defines the additional information returned from the Service Fabric API operations that are not successful.\n",
      "properties": {
        "Error": {
          "$ref": "#/definitions/FabricError_Error"
        }
      },
      "required": [
        "Error"
      ]
    },
    "FabricError_Error": {
      "type": "object",
      "description": "Error object containing error code and error message.",
      "properties": {
        "Code": {
          "$ref": "#/definitions/FabricErrorCodes"
        },
        "Message": {
          "type": "string",
          "description": "Error message."
        }
      },
      "required": [
        "Code"
      ]
    },
    "FabricErrorCodes": {
      "type": "string",
      "description": "Defines the fabric error codes that be returned as part of the error object in response to Service Fabric API operations that are not successful. Following are the error code values that can be returned for a specific HTTP status code.\n\n  - Possible values of the error code for HTTP status code 400 (Bad Request)\n    - \"FABRIC_E_INVALID_PARTITION_KEY\"\n    - \"FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR\"\n    - \"FABRIC_E_INVALID_ADDRESS\"\n    - \"FABRIC_E_APPLICATION_NOT_UPGRADING\"\n    - \"FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR\"\n    - \"FABRIC_E_FABRIC_NOT_UPGRADING\"\n    - \"FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR\"\n    - \"FABRIC_E_INVALID_CONFIGURATION\"\n    - \"FABRIC_E_INVALID_NAME_URI\"\n    - \"FABRIC_E_PATH_TOO_LONG\"\n    - \"FABRIC_E_KEY_TOO_LARGE\"\n    - \"FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED\"\n    - \"FABRIC_E_INVALID_ATOMIC_GROUP\"\n    - \"FABRIC_E_VALUE_EMPTY\"\n\n  - Possible values of the error code for HTTP status code 404 (Not Found)\n    - \"FABRIC_E_NODE_NOT_FOUND\"\n    - \"FABRIC_E_APPLICATION_TYPE_NOT_FOUND\"\n    - \"FABRIC_E_APPLICATION_NOT_FOUND\"\n    - \"FABRIC_E_SERVICE_TYPE_NOT_FOUND\"\n    - \"FABRIC_E_SERVICE_DOES_NOT_EXIST\"\n    - \"FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND\"\n    - \"FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND\"\n    - \"FABRIC_E_PARTITION_NOT_FOUND\"\n    - \"FABRIC_E_REPLICA_DOES_NOT_EXIST\"\n    - \"FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST\"\n    - \"FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND\"\n    - \"FABRIC_E_DIRECTORY_NOT_FOUND\"\n    - \"FABRIC_E_FABRIC_VERSION_NOT_FOUND\"\n    - \"FABRIC_E_FILE_NOT_FOUND\"\n    - \"FABRIC_E_NAME_DOES_NOT_EXIST\"\n    - \"FABRIC_E_PROPERTY_DOES_NOT_EXIST\"\n    - \"FABRIC_E_ENUMERATION_COMPLETED\"\n    - \"FABRIC_E_SERVICE_MANIFEST_NOT_FOUND\"\n    - \"FABRIC_E_KEY_NOT_FOUND\"\n    - \"FABRIC_E_HEALTH_ENTITY_NOT_FOUND\"\n\n  - Possible values of the error code for HTTP status code 409 (Conflict)\n    - \"FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS\"\n    - \"FABRIC_E_APPLICATION_ALREADY_EXISTS\"\n    - \"FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION\"\n    - \"FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS\"\n    - \"FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS\"\n    - \"FABRIC_E_SERVICE_ALREADY_EXISTS\"\n    - \"FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS\"\n    - \"FABRIC_E_APPLICATION_TYPE_IN_USE\"\n    - \"FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION\"\n    - \"FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS\"\n    - \"FABRIC_E_FABRIC_VERSION_IN_USE\"\n    - \"FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS\"\n    - \"FABRIC_E_NAME_ALREADY_EXISTS\"\n    - \"FABRIC_E_NAME_NOT_EMPTY\"\n    - \"FABRIC_E_PROPERTY_CHECK_FAILED\"\n    - \"FABRIC_E_SERVICE_METADATA_MISMATCH\"\n    - \"FABRIC_E_SERVICE_TYPE_MISMATCH\"\n    - \"FABRIC_E_HEALTH_STALE_REPORT\"\n    - \"FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED\"\n    - \"FABRIC_E_NODE_HAS_NOT_STOPPED_YET\"\n    - \"FABRIC_E_INSTANCE_ID_MISMATCH\"\n\n  - Possible values of the error code for HTTP status code 413 (Request Entity Too Large)\n    - \"FABRIC_E_VALUE_TOO_LARGE\"\n\n  - Possible values of the error code for HTTP status code 500 (Internal Server Error)\n    - \"FABRIC_E_NODE_IS_UP\"\n\n  - Possible values of the error code for HTTP status code 503 (Service Unavailable)\n    - \"FABRIC_E_NO_WRITE_QUORUM\"\n    - \"FABRIC_E_NOT_PRIMARY\"\n    - \"FABRIC_E_NOT_READY\"\n    - \"FABRIC_E_RECONFIGURATION_PENDING\"\n    - \"FABRIC_E_SERVICE_OFFLINE\"\n    - \"E_ABORT\"\n    - \"FABRIC_E_VALUE_TOO_LARGE\"\n\n  - Possible values of the error code for HTTP status code 504 (Gateway Timeout)\n    - \"FABRIC_E_COMMUNICATION_ERROR\"\n    - \"FABRIC_E_OPERATION_NOT_COMPLETE\"\n    - \"FABRIC_E_TIMEOUT\"\n",
      "enum": [
        "FABRIC_E_INVALID_PARTITION_KEY",
        "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR",
        "FABRIC_E_INVALID_ADDRESS",
        "FABRIC_E_APPLICATION_NOT_UPGRADING",
        "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
        "FABRIC_E_FABRIC_NOT_UPGRADING",
        "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
        "FABRIC_E_INVALID_CONFIGURATION",
        "FABRIC_E_INVALID_NAME_URI",
        "FABRIC_E_PATH_TOO_LONG",
        "FABRIC_E_KEY_TOO_LARGE",
        "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
        "FABRIC_E_INVALID_ATOMIC_GROUP",
        "FABRIC_E_VALUE_EMPTY",
        "FABRIC_E_NODE_NOT_FOUND",
        "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
        "FABRIC_E_APPLICATION_NOT_FOUND",
        "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
        "FABRIC_E_SERVICE_DOES_NOT_EXIST",
        "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
        "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
        "FABRIC_E_PARTITION_NOT_FOUND",
        "FABRIC_E_REPLICA_DOES_NOT_EXIST",
        "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
        "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
        "FABRIC_E_DIRECTORY_NOT_FOUND",
        "FABRIC_E_FABRIC_VERSION_NOT_FOUND",
        "FABRIC_E_FILE_NOT_FOUND",
        "FABRIC_E_NAME_DOES_NOT_EXIST",
        "FABRIC_E_PROPERTY_DOES_NOT_EXIST",
        "FABRIC_E_ENUMERATION_COMPLETED",
        "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND",
        "FABRIC_E_KEY_NOT_FOUND",
        "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
        "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
        "FABRIC_E_APPLICATION_ALREADY_EXISTS",
        "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
        "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
        "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
        "FABRIC_E_SERVICE_ALREADY_EXISTS",
        "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
        "FABRIC_E_APPLICATION_TYPE_IN_USE",
        "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
        "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS",
        "FABRIC_E_FABRIC_VERSION_IN_USE",
        "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS",
        "FABRIC_E_NAME_ALREADY_EXISTS",
        "FABRIC_E_NAME_NOT_EMPTY",
        "FABRIC_E_PROPERTY_CHECK_FAILED",
        "FABRIC_E_SERVICE_METADATA_MISMATCH",
        "FABRIC_E_SERVICE_TYPE_MISMATCH",
        "FABRIC_E_HEALTH_STALE_REPORT",
        "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
        "FABRIC_E_NODE_HAS_NOT_STOPPED_YET",
        "FABRIC_E_INSTANCE_ID_MISMATCH",
        "FABRIC_E_VALUE_TOO_LARGE",
        "FABRIC_E_NO_WRITE_QUORUM",
        "FABRIC_E_NOT_PRIMARY",
        "FABRIC_E_NOT_READY",
        "FABRIC_E_RECONFIGURATION_PENDING",
        "FABRIC_E_SERVICE_OFFLINE",
        "E_ABORT",
        "FABRIC_E_COMMUNICATION_ERROR",
        "FABRIC_E_OPERATION_NOT_COMPLETE",
        "FABRIC_E_TIMEOUT",
        "FABRIC_E_NODE_IS_UP"
      ]
    },
    "ClusterConfigurationUpgradeStatusInfo": {
      "type": "object",
      "description": "Information about a standalone cluster configuration upgrade status.",
      "properties": {
        "UpgradeState": {
          "$ref": "#/definitions/UpgradeState"
        },
        "ProgressStatus": {
          "type": "integer",
          "description": "The cluster manifest version."
        },
        "ConfigVersion": {
          "type": "string",
          "description": "The cluster configuration version."
        },
        "Details": {
          "type": "string",
          "description": "The cluster upgrade status details."
        }
      }
    },
    "FailureAction": {
      "type": "string",
      "description": "The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations.\n\n    - Invalid - Indicates the failure action is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - Rollback - The upgrade will start rolling back automatically. The value is 1\n    - Manual - The upgrade will switch to UnmonitoredManual upgrade mode. The value is 2\n",
      "enum": [
        "Invalid",
        "Rollback",
        "Manual"
      ]
    },
    "FailureReason": {
      "type": "string",
      "description": "The cause of an upgrade failure that resulted in FailureAction being executed.\n\n    - None - Indicates the reason is invalid or unknown. All Service Fabric enumerations have the invalid type. The value is zero.\n    - Interrupted - There was an external request to rollback the upgrade. The value is 1\n    - HealthCheck - The upgrade failed due to health policy violations. The value is 2\n    - UpgradeDomainTimeout - An upgrade domain took longer than the allowed upgrade domain timeout to process. The value is 3\n    - UpgradeTimeout - The overall upgrade took longer than the allowed upgrade timeout to process. The value is 4\n",
      "enum": [
        "None",
        "Interrupted",
        "HealthCheck",
        "UpgradeDomainTimeout",
        "UpgradeTimeout"
      ]
    },
    "FailureUpgradeDomainProgressInfo": {
      "type": "object",
      "description": "Information about the upgrade domain progress at the time of upgrade failure.",
      "properties": {
        "DomainName": {
          "$ref": "#/definitions/UpgradeDomainName"
        },
        "NodeUpgradeProgressList": {
          "$ref": "#/definitions/NodeUpgradeProgressInfoList"
        }
      }
    },
    "ForceRestart": {
      "type": "boolean",
      "description": "If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).",
      "default": false
    },
    "HealthCheckRetryTimeout": {
      "type": "string",
      "description": "The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "PT0H10M0S"
    },
    "HealthCheckStableDuration": {
      "type": "string",
      "description": "The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "PT0H2M0S"
    },
    "HealthCheckWaitDuration": {
      "type": "string",
      "description": "The amount of time to wait after completing an upgrade domain before applying health policies. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "0"
    },
    "HealthEvaluation": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Represents a health evaluation which describes the data and the algorithm used by health manager to evaluate the health of an entity.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/HealthEvaluationKind"
        },
        "AggregatedHealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "Description": {
          "type": "string",
          "description": "Description of the health evaluation, which represents a summary of the evaluation process."
        }
      },
      "required": [
        "Kind"
      ]
    },
    "HealthEvaluationKind": {
      "type": "string",
      "description": "The health manager in the cluster performs health evalautions in determining the aggregated health state of an entity. This enumeration provides information on the kind of evaluation that was performed. Following are the possible values.\n\n  - Invalid - Indicates that the health evaluation is invalid. The value is zero.\n  - Event - Indicates that the health evaluation is for a health event. The value is 1.\n  - Replicas - Indicates that the health evaluation is for the replicas of a partition. The value is 2.\n  - Partitions - Indicates that the health evaluation is for the partitions of a service. The value is 3.\n  - DeployedServicePackages - Indicates that the health evaluation is for the deployed service packages of a deployed application. The value is 4.\n  - DeployedApplications - Indicates that the health evaluation is for the deployed applications of an application. The value is 5.\n  - Services - Indicates that the health evaluation is for services of an application. The value is 6.\n  - Nodes - Indicates that the health evaluation is for the cluster nodes. The value is 7.\n  - Applications - Indicates that the health evaluation is for the cluster applications. The value is 8.\n  - SystemApplication - Indicates that the health evaluation is for the system application. The value is 9.\n  - UpgradeDomainDeployedApplications - Indicates that the health evaluation is for the deployed applications of an application in an upgrade domain. The value is 10.\n  - UpgradeDomainNodes - Indicates that the health evaluation is for the cluster nodes in an upgrade domain. The value is 11.\n  - Node - Indicates that the health evaluation is for a node. The value is 12.\n  - Replica - Indicates that the health evaluation is for a replica. The value is 13.\n  - Partition - Indicates that the health evaluation is for a partition. The value is 14.\n  - Service - Indicates that the health evaluation is for a service. The value is 15.\n  - DeployedServicePackage - Indicates that the health evaluation is for a deployed service package. The value is 16.\n  - DeployedApplication - Indicates that the health evaluation is for a deployed application. The value is 17.\n  - Application - Indicates that the health evaluation is for an application. The value is 18.\n  - DeltaNodesCheck - Indicates that the health evaluation is for the delta of unhealthy cluster nodes. The value is 19.\n  - UpgradeDomainDeltaNodesCheck - Indicates that the health evaluation is for the delta of unhealthy upgrade domain cluster nodes. The value is 20.\n  - ApplicationTypeApplications  Indicates that the health evaluation is for applications of an application type. The value is 21.\n",
      "enum": [
        "Invalid",
        "Event",
        "Replicas",
        "Partitions",
        "DeployedServicePackages",
        "DeployedApplications",
        "Services",
        "Nodes",
        "Applications",
        "SystemApplication",
        "UpgradeDomainDeployedApplications",
        "UpgradeDomainNodes",
        "Replica",
        "Partition",
        "DeployedServicePackage",
        "DeployedApplication",
        "Service",
        "Node",
        "Application",
        "DeltaNodesCheck",
        "UpgradeDomainDeltaNodesCheck",
        "ApplicationTypeApplications"
      ]
    },
    "HealthEvaluationWrapper": {
      "type": "object",
      "description": "Wrapper object for health evaluation.",
      "properties": {
        "HealthEvaluation": {
          "$ref": "#/definitions/HealthEvaluation"
        }
      }
    },
    "HealthEvent": {
      "description": "Represents health information reported on a health entity, such as cluster, application or node, with additional metadata added by the Health Manager.\n",
      "allOf": [
        {
          "$ref": "#/definitions/HealthInformation"
        },
        {
          "type": "object",
          "description": "HealthEvent",
          "properties": {
            "IsExpired": {
              "type": "boolean",
              "description": "Returns true if the health event is expired, otherwise false."
            },
            "SourceUtcTimestamp": {
              "type": "string",
              "format": "date-time",
              "description": "The date and time when the health report was sent by the source."
            },
            "LastModifiedUtcTimestamp": {
              "type": "string",
              "format": "date-time",
              "description": "The date and time when the health report was last modified by the health store."
            },
            "LastOkTransitionAt": {
              "type": "string",
              "format": "date-time",
              "description": "If the current health state is 'Ok', this property returns the time at which the health report was first reported with 'Ok'.\nFor periodic reporting, many reports with the same state may have been generated.\nThis property returns the date and time when the first 'Ok' health report was received.\n\nIf the current health state is 'Error' or 'Warning', returns the date and time at which the health state was last in 'Ok', before transitioning to a different state.\n\nIf the health state was never 'Ok', the value will be zero date-time.\n"
            },
            "LastWarningTransitionAt": {
              "type": "string",
              "format": "date-time",
              "description": "If the current health state is 'Warning', this property returns the time at which the health report was first reported with 'Warning'. For periodic reporting, many reports with the same state may have been generated however, this property returns only the date and time at the first 'Warning' health report was received.\n\nIf the current health state is 'Ok' or 'Error', returns the date and time at which the health state was last in 'Warning', before transitioning to a different state.\n\nIf the health state was never 'Warning', the value will be zero date-time.\n"
            },
            "LastErrorTransitionAt": {
              "type": "string",
              "format": "date-time",
              "description": "If the current health state is 'Error', this property returns the time at which the health report was first reported with 'Error'. For periodic reporting, many reports with the same state may have been generated however, this property returns only the date and time at the first 'Error' health report was received.\n\nIf the current health state is 'Ok' or 'Warning', returns the date and time at which the health state was last in 'Error', before transitioning to a different state.\n\nIf the health state was never 'Error', the value will be zero date-time.\n"
            }
          }
        }
      ]
    },
    "HealthInformation": {
      "type": "object",
      "description": "Represents common health report information. It is included in all health reports sent to health store and in all health events returned by health queries.\n",
      "required": [
        "SourceId",
        "Property",
        "HealthState"
      ],
      "properties": {
        "SourceId": {
          "type": "string",
          "description": "The source name which identifies the client/watchdog/system component which generated the health information.\n"
        },
        "Property": {
          "type": "string",
          "description": "The property of the health information. An entity can have health reports for different properties.\nThe property is a string and not a fixed enumeration to allow the reporter flexibility to categorize the state condition that triggers the report.\nFor example, a reporter with SourceId \"LocalWatchdog\" can monitor the state of the available disk on a node,\nso it can report \"AvailableDisk\" property on that node.\nThe same reporter can monitor the node connectivity, so it can report a property \"Connectivity\" on the same node.\nIn the health store, these reports are treated as separate health events for the specified node.\n\nTogether with the SourceId, the property uniquely identifies the health information.\n"
        },
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "TimeToLiveInMilliSeconds": {
          "type": "string",
          "format": "duration",
          "description": "The duration for which this health report is valid. This field is using ISO8601 format for specifying the duration.\nWhen clients report periodically, they should send reports with higher frequency than time to live.\nIf clients report on transition, they can set the time to live to infinite.\nWhen time to live expires, the health event that contains the health information\nis either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired false.\n\nIf not specified, time to live defaults to infinite value.\n"
        },
        "Description": {
          "type": "string",
          "description": "The description of the health information. It represents free text used to add human readable information about the report.\nThe maximum string length for the description is 4096 characters.\nIf the provided string is longer, it will be automatically truncated.\nWhen truncated, the last characters of the description contain a marker \"[Truncated]\", and total string size is 4096 characters.\nThe presence of the marker indicates to users that truncation occurred.\nNote that when truncated, the description has less than 4096 characters from the original string.\n"
        },
        "SequenceNumber": {
          "type": "string",
          "description": "The sequence number for this health report as a numeric string.\nThe report sequence number is used by the health store to detect stale reports.\nIf not specified, a sequence number is auto-generated by the health client when a report is added.\n"
        },
        "RemoveWhenExpired": {
          "type": "boolean",
          "description": "Value that indicates whether the report is removed from health store when it expires.\nIf set to true, the report is remopved from the health store after it expires.\nIf set to false, the report is treated as an error when expired. The value of this property is false by default.\nWhen clients report periodically, they should set RemoveWhenExpired false (default).\nThis way, is the reporter has issues (eg. deadlock) and can't report, the entity is evaluated at error when the health report expires.\nThis flags the entity as being in Error health state.\n"
        }
      }
    },
    "HealthState": {
      "type": "string",
      "description": "The health state of a Service Fabric entity such as Cluster, Node, Application, Service, Partition, Replica etc.\n\n  - Invalid - Indicates an invalid health state. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Ok - Indicates the health state is okay. The value is 1.\n  - Warning - Indicates the health state is at a warning level. The value is 2.\n  - Error - Indicates the health state is at an error level. Error health state should be investigated, as they can impact the correct functionality of the cluster. The value is 3.\n  - Unknown - Indicates an unknown health status. The value is 65535.\n",
      "enum": [
        "Invalid",
        "Ok",
        "Warning",
        "Error",
        "Unknown"
      ]
    },
    "Int64RangePartitionInformation": {
      "description": "Describes the partition information for the integer range that is based on partition schemes.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionInformation"
        },
        {
          "type": "object",
          "description": "StatelessServicePartitionInfo"
        }
      ],
      "x-ms-discriminator-value": "Int64Range",
      "properties": {
        "LowKey": {
          "type": "string",
          "description": "Specifies the minimum key value handled by this partition."
        },
        "HighKey": {
          "type": "string",
          "description": "Specifies the maximum key value handled by this partition."
        }
      }
    },
    "MonitoringPolicyDescription": {
      "type": "object",
      "description": "Describes the parameters for monitoring an upgrade in Monitored mode.",
      "properties": {
        "FailureAction": {
          "$ref": "#/definitions/FailureAction"
        },
        "HealthCheckWaitDurationInMilliseconds": {
          "$ref": "#/definitions/HealthCheckWaitDuration"
        },
        "HealthCheckStableDurationInMilliseconds": {
          "$ref": "#/definitions/HealthCheckStableDuration"
        },
        "HealthCheckRetryTimeoutInMilliseconds": {
          "$ref": "#/definitions/HealthCheckRetryTimeout"
        },
        "UpgradeTimeoutInMilliseconds": {
          "$ref": "#/definitions/UpgradeTimeout"
        },
        "UpgradeDomainTimeoutInMilliseconds": {
          "$ref": "#/definitions/UpgradeDomainTimeout"
        }
      }
    },
    "NamedPartitionInformation": {
      "description": "Describes the partition information for the name as a string that is based on partition schemes.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionInformation"
        },
        {
          "type": "object",
          "description": "StatelessServicePartitionInfo"
        }
      ],
      "x-ms-discriminator-value": "Named",
      "properties": {
        "Name": {
          "type": "string",
          "description": "Name of the partition."
        }
      }
    },
    "NextUpgradeDomain": {
      "type": "string",
      "description": "The name of the next upgrade domain to be processed."
    },
    "NodeDeactivationInfo": {
      "type": "object",
      "description": "Information about the node deactivation. This information is valid for a node that is undergoing deactivation or has already been deactivated.",
      "properties": {
        "NodeDeactivationIntent": {
          "$ref": "#/definitions/NodeDeactivationIntent"
        },
        "NodeDeactivationStatus": {
          "$ref": "#/definitions/NodeDeactivationStatus"
        },
        "NodeDeactivationTask": {
          "$ref": "#/definitions/NodeDeactivationTaskList"
        },
        "PendingSafetyChecks": {
          "$ref": "#/definitions/SafetyCheckInfoList"
        }
      }
    },
    "NodeDeactivationIntent": {
      "type": "string",
      "description": "The intent or the reason for deactivating the node. Following are the possible values for it.\n\n  - Invalid - Indicates the node deactivation intent is invalid. All Service Fabric enumerations have the invalid type. The value is zero. This value is not used.\n  - Pause - Indicates that the node should be paused. The value is 1.\n  - Restart - Indicates that the intent is for the node to be restarted after a short period of time. Service Fabric does not restart the node, this action is done outside of Service Fabric. The value is 2.\n  - RemoveData - Indicates that the intent is to reimage the node. Service Fabric does not reimage the node, this action is done outside of Service Fabric. The value is 3.\n  - RemoveNode - Indicates that the node is being decommissioned and is not expected to return. Service Fabric does not decommission the node, this action is done outside of Service Fabric. The value is 4.\n",
      "enum": [
        "Invalid",
        "Pause",
        "Restart",
        "RemoveData",
        "RemoveNode"
      ]
    },
    "NodeDeactivationStatus": {
      "type": "string",
      "description": "The status of node deactivation operation. Following are the possible values.\n\n  - None - No status is associated with the task. The value is zero.\n  - SafetyCheckInProgress - When a node is deactivated Service Fabric performs checks to ensure that the operation is safe to proceed to ensure avaiablity of the service and reliability of the state. This value indicates that one or more safety checks are in progress. The value is 1.\n  - SafetyCheckComplete - When a node is deactivated Service Fabric performs checks to ensure that the operation is safe to proceed to ensure avaiablity of the service and reliability of the state. This value indicates that all safety checks have been completed. The value is 2.\n  - Completed - The task is completed. The value is 3.\n",
      "enum": [
        "None",
        "SafetyCheckInProgress",
        "SafetyCheckComplete",
        "Completed"
      ]
    },
    "NodeDeactivationTask": {
      "type": "object",
      "description": "The task representing the deactivation operation on the node.",
      "properties": {
        "NodeDeactivationTaskId": {
          "$ref": "#/definitions/NodeDeactivationTaskId"
        },
        "NodeDeactivationIntent": {
          "$ref": "#/definitions/NodeDeactivationIntent"
        }
      }
    },
    "NodeDeactivationTaskId": {
      "type": "object",
      "description": "Identity of the task related to deactivation operation on the node.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "Value of the task id."
        },
        "NodeDeactivationTaskType": {
          "$ref": "#/definitions/NodeDeactivationTaskType"
        }
      }
    },
    "NodeDeactivationTaskList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/NodeDeactivationTask"
      },
      "description": "List of tasks representing the deactivation operation on the node."
    },
    "NodeDeactivationTaskType": {
      "type": "string",
      "description": "The type of the task that performed the node deactivation. Following are the possible values.\n\n  - Invalid - Indicates the node deactivation task type is invalid. All Service Fabric enumerations have the invalid type. The value is zero. This value is not used.\n  - Infrastructure - Specifies the task created by Infrastructure hosting the nodes. The value is 1.\n  - Repair - Specifies the task that was created by the Repair Manager service. The value is 2.\n  - Client - Specifies that the task was created by using the public API. The value is 3.\n",
      "enum": [
        "Invalid",
        "Infrastructure",
        "Repair",
        "Client"
      ]
    },
    "NodeHealth": {
      "description": "Information about the health of a Service Fabric node.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "NodeHealth",
          "properties": {
            "Name": {
              "$ref": "#/definitions/NodeName"
            }
          }
        }
      ]
    },
    "NodeHealthEvaluation": {
      "x-ms-discriminator-value": "Node",
      "description": "Represents health evaluation for a node, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "NodeHealthEvaluation",
          "properties": {
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "NodeHealthState": {
      "description": "Represents the health state of a node, which contains the node identifier and its aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "NodeHealthState",
          "properties": {
            "Name": {
              "$ref": "#/definitions/NodeName"
            },
            "Id": {
              "$ref": "#/definitions/NodeId"
            }
          }
        }
      ]
    },
    "NodeHealthStateChunk": {
      "description": "Represents the health state chunk of a node, which contains the node name and its aggregated health state.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "NodeHealthStateChunk",
          "properties": {
            "NodeName": {
              "$ref": "#/definitions/NodeName"
            }
          }
        }
      ]
    },
    "NodeHealthStateChunkList": {
      "type": "object",
      "description": "The list of node health state chunks in the cluster that respect the input filters in the chunk query. Returned by get cluster health state chunks query.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunkList"
        },
        {
          "type": "object",
          "description": "NodeHealthStateChunkList",
          "properties": {
            "Items": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/NodeHealthStateChunk"
              },
              "description": "The list of node health state chunks that respect the input filters in the chunk query.\n"
            }
          }
        }
      ]
    },
    "NodeHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a node should be included in the returned cluster health chunk.\nOne filter can match zero, one or multiple nodes, depending on its properties.\nCan be specified in the cluster health chunk query description.\n",
      "properties": {
        "NodeNameFilter": {
          "type": "string",
          "description": "Name of the node that matches the filter. The filter is applied only to the specified node, if it exists.\nIf the node doesn't exist, no node is returned in the cluster health chunk based on this filter.\nIf the node exists, it is included in the cluster health chunk if the health state matches the other filter properties.\nIf not specified, all nodes that match the parent filters (if any) are taken into consideration and matched against the other filter members, like health state filter.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the nodes. It allows selecting nodes if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the cluster aggregated health state.\nIf not specified, default value is None, unless the node name is specified. If the filter has default value and node name is specified, the matching node is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches nodes with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        }
      }
    },
    "NodeId": {
      "type": "object",
      "description": "An internal ID used by Service Fabric to uniquely identify a node. Node Id is deterministically generated from node name.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "Value of the node Id. This is a 128 bit integer."
        }
      }
    },
    "NodeInfo": {
      "type": "object",
      "description": "Information about a node in Service Fabric cluster.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/NodeName"
        },
        "IpAddressOrFQDN": {
          "type": "string",
          "description": "The IP address or fully qualified domain name of the node."
        },
        "Type": {
          "type": "string",
          "description": "The type of the node."
        },
        "CodeVersion": {
          "type": "string",
          "description": "The version of Service Fabric binaries that the node is running."
        },
        "ConfigVersion": {
          "type": "string",
          "description": "The version of Service Fabric cluster manifest that the node is using."
        },
        "NodeStatus": {
          "$ref": "#/definitions/NodeStatus"
        },
        "NodeUpTimeInSeconds": {
          "type": "string",
          "description": "Time in seconds since the node has been in NodeStatus Up. Value ero indicates that the node is not Up."
        },
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "IsSeedNode": {
          "type": "boolean",
          "description": "Indicates if the node is a seed node or not. Returns true if the node is a seed node, otherwise false. A quorum of seed nodes are required for proper operation of Service Fabric cluster."
        },
        "UpgradeDomain": {
          "type": "string",
          "description": "The upgrade domain of the node."
        },
        "FaultDomain": {
          "type": "string",
          "description": "The fault domain of the node."
        },
        "Id": {
          "$ref": "#/definitions/NodeId"
        },
        "InstanceId": {
          "type": "string",
          "description": "The id representing the node instance. While the Id of the node is deterministically generated from the node name and remains same across restarts, the InstanceId changes every time node restarts."
        },
        "NodeDeactivationInfo": {
          "$ref": "#/definitions/NodeDeactivationInfo"
        },
        "IsStopped": {
          "type": "boolean",
          "description": "Indicates if the node is stopped by calling stop node API or not. Returns true if the node is stopped, otherwise false."
        },
        "NodeDownTimeInSeconds": {
          "type": "string",
          "description": "Time in seconds since the node has been in NodeStatus Down. Value zero indicates node is not NodeStatus Down."
        },
        "NodeUpAt": {
          "type": "string",
          "format": "date-time",
          "description": "Date time in UTC when the node came up. If the node has never been up then this value will be zero date time."
        },
        "NodeDownAt": {
          "type": "string",
          "format": "date-time",
          "description": "Date time in UTC when the node went down. If node has never been down then this value will be zero date time."
        }
      }
    },
    "NodeLoadInfo": {
      "type": "object",
      "description": "Information about load on a Service Fabric node. It holds a summary of all metrics and their load on a node.",
      "properties": {
        "NodeName": {
          "$ref": "#/definitions/NodeName"
        },
        "NodeLoadMetricInformation": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NodeLoadMetricInformation"
          },
          "description": "List that contains metrics and their load information on this node."
        }
      }
    },
    "NodeLoadMetricInformation": {
      "type": "object",
      "description": "Represents data structure that contains load information for a certain metric on a node.",
      "properties": {
        "Name": {
          "type": "string",
          "description": "Name of the metric for which this load information is provided."
        },
        "NodeCapacity": {
          "type": "string",
          "description": "Total capacity on the node for this metric."
        },
        "NodeLoad": {
          "type": "string",
          "description": "Current load on the node for this metric."
        },
        "NodeRemainingCapacity": {
          "type": "string",
          "description": "The remaining capacity on the node for this metric."
        },
        "IsCapacityViolation": {
          "type": "boolean",
          "description": "Indicates if there is a capacity violation for this metric on the node."
        },
        "NodeBufferedCapacity": {
          "type": "string",
          "description": "The value that indicates the reserved capacity for this metric on the node."
        },
        "NodeRemainingBufferedCapacity": {
          "type": "string",
          "description": "The remaining reserved capacity for this metric on the node."
        }
      }
    },
    "NodeName": {
      "type": "string",
      "description": "The name of a Service Fabric node."
    },
    "NodesHealthEvaluation": {
      "x-ms-discriminator-value": "Nodes",
      "description": "Represents health evaluation for nodes, containing health evaluations for each unhealthy node that impacted current aggregated health state. Can be returned when evaluating cluster health and the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "NodesHealthEvaluation",
          "properties": {
            "MaxPercentUnhealthyNodes": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy nodes from the ClusterHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of nodes found in the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "NodeStatus": {
      "type": "string",
      "description": "The status of the node. Possible values are following.\n\n  - Invalid - Indicates the node status is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Up - Indicates the node is up. The value is 1.\n  - Down - Indicates the node is down. The value is 2.\n  - Enabling - Indicates the node is in process of being enabled. The value is 3.\n  - Disabling - Indicates the node is in the process of being disabled. The value is 4.\n  - Disabled - Indicates the node is disabled. The value is 5.\n  - Unknown - Indicates the node is unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.The value is 6.\n  - Removed - Indicates the node is removed. A node would be in Removed state if NodeStateRemoved API has been called for this node. In other words, Service Fabric has been informed that the persisted state on the node has been permanently lost. The value is 7.\n",
      "enum": [
        "Invalid",
        "Up",
        "Down",
        "Enabling",
        "Disabling",
        "Disabled",
        "Unknown",
        "Removed"
      ]
    },
    "NodeUpgradePhase": {
      "type": "string",
      "description": "The state of the upgrading node.\n\n  - Invalid - Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - PreUpgradeSafetyCheck - The upgrade has not started yet due to pending safety checks. The value is 1\n  - Upgrading - The upgrade is in progress. The value is 2\n  - PostUpgradeSafetyCheck - The upgrade has completed and post upgrade safety checks are being performed. The value is 3\n",
      "enum": [
        "Invalid",
        "PreUpgradeSafetyCheck",
        "Upgrading",
        "PostUpgradeSafetyCheck"
      ]
    },
    "NodeUpgradeProgressInfo": {
      "type": "object",
      "description": "Information about the upgrading node and its status",
      "properties": {
        "NodeName": {
          "$ref": "#/definitions/NodeName"
        },
        "UpgradePhase": {
          "$ref": "#/definitions/NodeUpgradePhase"
        },
        "PendingSafetyChecks": {
          "$ref": "#/definitions/SafetyCheckInfoList"
        }
      }
    },
    "NodeUpgradeProgressInfoList": {
      "type": "array",
      "description": "List of upgrading nodes and their statuses",
      "items": {
        "$ref": "#/definitions/NodeUpgradeProgressInfo"
      }
    },
    "PagedApplicationInfoList": {
      "type": "object",
      "description": "The list of applications in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ApplicationInfo"
          }
        }
      }
    },
    "PagedNodeInfoList": {
      "type": "object",
      "description": "The list of nodes in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NodeInfo"
          }
        }
      }
    },
    "PagedServicePartitionInfoList": {
      "type": "object",
      "description": "The list of partition in the cluster for a service. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServicePartitionInfo"
          }
        }
      }
    },
    "PagedReplicaInfoList": {
      "type": "object",
      "description": "The list of replicas in the cluster for a given partition. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ReplicaInfo"
          }
        }
      }
    },
    "PagedServiceInfoList": {
      "type": "object",
      "description": "The list of services in the cluster for an application. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceInfo"
          }
        }
      }
    },
    "PartitionHealth": {
      "description": "Information about the health of a Service Fabric partition.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "PartitionHealth",
          "properties": {
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            },
            "ReplicaHealthStates": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ReplicaHealthState"
              },
              "description": "The list of replica health states associated with the partition."
            }
          }
        }
      ]
    },
    "PartitionHealthEvaluation": {
      "x-ms-discriminator-value": "Partition",
      "description": "Represents health evaluation for a partition, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "PartitionHealthEvaluation",
          "properties": {
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "PartitionHealthState": {
      "description": "Represents the health state of a partition, which contains the partition identifier and its aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "PartitionHealthState",
          "properties": {
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            }
          }
        }
      ]
    },
    "PartitionHealthStateChunk": {
      "description": "Represents the health state chunk of a partition, which contains the partition id, its aggregated health state and any replicas that respect the filters in the cluster health chunk query description.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "PartitionHealthStateChunk",
          "properties": {
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            },
            "ReplicaHealthStateChunks": {
              "$ref": "#/definitions/ReplicaHealthStateChunkList"
            }
          }
        }
      ]
    },
    "PartitionHealthStateChunkList": {
      "type": "object",
      "description": "The list of partition health state chunks that respect the input filters in the chunk query description.\nReturned by get cluster health state chunks query as part of the parent application hierarchy.\n",
      "properties": {
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PartitionHealthStateChunk"
          },
          "description": "The list of partition health state chunks that respect the input filters in the chunk query.\n"
        }
      }
    },
    "PartitionHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a partition should be included as a child of a service in the cluster health chunk.\nThe partitions are only returned if the parent entities match a filter specified in the cluster health chunk query description. The parent service and application must be included in the cluster health chunk.\nOne filter can match zero, one or multiple partitions, depending on its properties.\n",
      "properties": {
        "PartitionIdFilter": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the partition that matches the filter. The filter is applied only to the specified partition, if it exists.\nIf the partition doesn't exist, no partition is returned in the cluster health chunk based on this filter.\nIf the partition exists, it is included in the cluster health chunk if it respects the other filter properties.\nIf not specified, all partitions that match the parent filters (if any) are taken into consideration and matched against the other filter members, like health state filter.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the partitions. It allows selecting partitions if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only partitions that match the filter are returned. All partitions are used to evaluate the cluster aggregated health state.\nIf not specified, default value is None, unless the partition id is specified. If the filter has default value and partition id is specified, the matching partition is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches partitions with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        },
        "ReplicaFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ReplicaHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which replicas to be included in the returned cluster health chunk as children of the parent partition. The replicas are returned only if the parent partition matches a filter.\nIf the list is empty, no replicas are returned. All the replicas are used to evaluate the parent partition aggregated health state, regardless of the input filters.\nThe partition filter may specify multiple replica filters.\nFor example, it can specify a filter to return all replicas with health state Error and another filter to always include a replica identified by its replica id.\n"
        }
      }
    },
    "PartitionId": {
      "type": "string",
      "format": "uuid",
      "description": "An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly generated GUID when the service was created. The partition id is unique and does not change for the lifetime of the service. If the same service was deleted and recreated the ids of its partitions would be different."
    },
    "PartitionInformation": {
      "type": "object",
      "discriminator": "ServicePartitionKind",
      "description": "Information about the partition identity, partitioning scheme and keys supported by it.",
      "required": [
        "ServicePartitionKind"
      ],
      "properties": {
        "ServicePartitionKind": {
          "$ref": "#/definitions/ServicePartitionKind"
        },
        "Id": {
          "$ref": "#/definitions/PartitionId"
        }
      }
    },
    "ProvisionFabricDescription": {
      "type": "object",
      "description": "Describes the parameters for provisioning a cluster.",
      "properties": {
        "CodeFilePath": {
          "type": "string",
          "description": "The cluster code package file path."
        },
        "ClusterManifestFilePath": {
          "type": "string",
          "description": "The cluster manifest file path."
        }
      }
    },
    "UnprovisionFabricDescription": {
      "type": "object",
      "description": "Describes the parameters for unprovisioning a cluster.",
      "properties": {
        "CodeVersion": {
          "type": "string",
          "description": "The cluster code package version."
        },
        "ConfigVersion": {
          "type": "string",
          "description": "The cluster manifest version."
        }
      }
    },
    "ResumeClusterUpgradeDescription": {
      "type": "object",
      "description": "Describes the parameters for resuming a cluster upgrade.",
      "properties": {
        "UpgradeDomain": {
          "type": "string",
          "description": "The next upgrade domain for this cluster upgrade."
        }
      },
      "required": [
        "UpgradeDomain"
      ]
    },
    "StartClusterUpgradeDescription": {
      "type": "object",
      "description": "Describes the parameters for starting a cluster upgrade.",
      "properties": {
        "CodeVersion": {
          "type": "string",
          "description": "The cluster code version."
        },
        "ConfigVersion": {
          "type": "string",
          "description": "The cluster configuration version."
        },
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeKind"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "UpgradeReplicaSetCheckTimeoutInSeconds": {
          "$ref": "#/definitions/UpgradeReplicaSetCheckTimeout"
        },
        "ForceRestart": {
          "$ref": "#/definitions/ForceRestart"
        },
        "MonitoringPolicy": {
          "$ref": "#/definitions/MonitoringPolicyDescription"
        },
        "ClusterHealthPolicy": {
          "$ref": "#/definitions/ClusterHealthPolicy"
        },
        "EnableDeltaHealthEvaluation": {
          "type": "boolean",
          "description": "When true, enables delta health evaluation rather than absolute health evaluation after completion of each upgrade domain."
        },
        "ClusterUpgradeHealthPolicy": {
          "$ref": "#/definitions/ClusterUpgradeHealthPolicyObject"
        },
        "ApplicationHealthPolicyMap": {
          "$ref": "#/definitions/ApplicationHealthPolicies"
        }
      }
    },
    "UpdateClusterUpgradeDescription": {
      "description": "Parameters for updating a cluster upgrade.",
      "properties": {
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeType"
        },
        "UpdateDescription": {
          "$ref": "#/definitions/RollingUpgradeUpdateDescription"
        },
        "ClusterHealthPolicy": {
          "$ref": "#/definitions/ClusterHealthPolicy"
        },
        "EnableDeltaHealthEvaluation": {
          "$ref": "#/definitions/DeltaHealthEvaluationBool"
        },
        "ClusterUpgradeHealthPolicy": {
          "$ref": "#/definitions/ClusterUpgradeHealthPolicyObject"
        },
        "ApplicationHealthPolicyMap": {
          "$ref": "#/definitions/ApplicationHealthPolicies"
        }
      }
    },
    "SafetyCheckKind": {
      "type": "string",
      "description": "The kind of safety check performed by service fabric before continuing with the operations. These checks ensure the availability of the service and the reliability of the state. Following are the kinds of safety checks.\n\n- Invalid - Indicates that the upgrade safety check kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n- EnsureSeedNodeQuorum - Indicates that if we bring down the node then this will result in global seed node quorum loss. The value is 1.\n- EnsurePartitionQuorum - Indicates that there is some partition for which if we bring down the replica on the node, it will result in quorum loss for that partition. The value is 2.\n- WaitForPrimaryPlacement - Indicates that there is some replica on the node that was moved out of this node due to upgrade. Service Fabric is now waiting for the primary to be moved back to this node. The value is 3.\n- WaitForPrimarySwap - Indicates that Service Fabric is waiting for a primary replica to be moved out of the node before starting upgrade on that node. The value is 4.\n- WaitForReconfiguration - Indicates that there is some replica on the node that is involved in a reconfiguration. Service Fabric is waiting for the reconfiguration to be complete before staring upgrade on that node. The value is 5.\n- WaitForInbuildReplica - Indicates that there is either a replica on the node that is going through copy, or there is a primary replica on the node that is copying data to some other replica. In both cases, bringing down the replica on the node due to upgrade will abort the copy. The value is 6.\n- EnsureAvailability - Indicates that there is either a stateless service partition on the node having exactly one instance, or there is a primary replica on the node for which the partition is quorum loss. In both cases, bringing down the replicas due to upgrade will result in loss of availability. The value is 7.\n",
      "enum": [
        "Invalid",
        "EnsureSeedNodeQuorum",
        "EnsurePartitionQuorum",
        "WaitForPrimaryPlacement",
        "WaitForPrimarySwap",
        "WaitForReconfiguration",
        "WaitForInbuildReplica",
        "EnsureAvailability"
      ]
    },
    "SafetyCheck": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Represents a safety check performed by service fabric before continuing with the operations. These checks ensure the availability of the service and the reliability of the state.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/SafetyCheckKind"
        }
      },
      "required": [
        "Kind"
      ]
    },
    "PartitionSafetyCheck": {
      "description": "Represents a safety check for the service partition being performed by service fabric before continuing with operations.",
      "allOf": [
        {
          "$ref": "#/definitions/SafetyCheck"
        },
        {
          "type": "object",
          "description": "PartitionSafetyCheck",
          "properties": {
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            }
          }
        }
      ]
    },
    "EnsureAvailabilitySafetyCheck": {
      "description": "Safety check that waits to ensure the availability of the partition. It waits until there are replicas available such that bringing down this replica will not cause availability loss for the partition.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSafetyCheck"
        },
        {
          "type": "object",
          "description": "EnsureAvailabilitySafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "EnsureAvailability"
    },
    "EnsurePartitionQurumSafetyCheck": {
      "description": "Safety check that ensures that a quorum of replicas are not lost for a partition.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSafetyCheck"
        },
        {
          "type": "object",
          "description": "EnsurePartitionQurumSafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "EnsurePartitionQuorum"
    },
    "SeedNodeSafetyCheck": {
      "description": "Represents a safety check for the seed nodes being performed by service fabric before continuing with node level operations.",
      "allOf": [
        {
          "$ref": "#/definitions/SafetyCheck"
        },
        {
          "type": "object",
          "description": "SeedNodeSafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "EnsureSeedNodeQuorum"
    },
    "PartitionsHealthEvaluation": {
      "x-ms-discriminator-value": "Partitions",
      "description": "Represents health evaluation for the partitions of a service, containing health evaluations for each unhealthy partition that impacts current aggregated health state. Can be returned when evaluating service health and the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "PartitionsHealthEvaluation",
          "properties": {
            "MaxPercentUnhealthyPartitionsPerService": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy partitions per service from the ServiceTypeHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of partitions of the service from the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ReplicaHealth": {
      "discriminator": "ServiceKind",
      "description": "Represents a base class for stateful service replica or stateless service instance health.\nContains the replica aggregated health state, the health events and the unhealthy evaluations.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "ReplicaHealth",
          "properties": {
            "ServiceKind": {
              "$ref": "#/definitions/ServiceKind"
            },
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            }
          },
          "required": [
            "ServiceKind"
          ]
        }
      ]
    },
    "ReplicaHealthEvaluation": {
      "x-ms-discriminator-value": "Replica",
      "description": "Represents health evaluation for a replica, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ReplicaHealthEvaluation",
          "properties": {
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            },
            "ReplicaOrInstanceId": {
              "$ref": "#/definitions/ReplicaOrInstanceId"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ReplicaHealthState": {
      "type": "object",
      "discriminator": "ServiceKind",
      "required": [
        "ServiceKind"
      ],
      "description": "Represents a base class for stateful service replica or stateless service instance health state.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "ReplicaHealthState",
          "properties": {
            "ServiceKind": {
              "$ref": "#/definitions/ServiceKind"
            },
            "PartitionId": {
              "$ref": "#/definitions/PartitionId"
            }
          }
        }
      ]
    },
    "ReplicaHealthStateChunk": {
      "description": "Represents the health state chunk of a stateful service replica or a stateless service instance.\nThe replica health state contains the replica ID and its aggregated health state.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "ReplicaHealthStateChunk",
          "properties": {
            "ReplicaOrInstanceId": {
              "$ref": "#/definitions/ReplicaOrInstanceId"
            }
          }
        }
      ]
    },
    "ReplicaHealthStateChunkList": {
      "type": "object",
      "description": "The list of replica health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.\n",
      "properties": {
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ReplicaHealthStateChunk"
          },
          "description": "The list of replica health state chunks that respect the input filters in the chunk query.\n"
        }
      }
    },
    "ReplicaHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a replica should be included as a child of a partition in the cluster health chunk.\nThe replicas are only returned if the parent entities match a filter specified in the cluster health chunk query description. The parent partition, service and application must be included in the cluster health chunk.\nOne filter can match zero, one or multiple replicas, depending on its properties.\n",
      "properties": {
        "ReplicaOrInstanceIdFilter": {
          "type": "string",
          "description": "Id of the stateful service replica or stateles service instance that matches the filter. The filter is applied only to the specified replica, if it exists.\nIf the replica doesn't exist, no replica is returned in the cluster health chunk based on this filter.\nIf the replica exists, it is included in the cluster health chunk if it respects the other filter properties.\nIf not specified, all replicas that match the parent filters (if any) are taken into consideration and matched against the other filter members, like health state filter.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the replicas. It allows selecting replicas if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only replicas that match the filter are returned. All replicas are used to evaluate the parent partition aggregated health state.\nIf not specified, default value is None, unless the replica id is specified. If the filter has default value and replica id is specified, the matching replica is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches replicas with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        }
      }
    },
    "ReplicaId": {
      "type": "string",
      "description": "Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a replica of a partition. It is unique within a partition and does not change for the lifetime of the replica. If a replica gets dropped and another replica gets created on the same node for the same partition, it will get a different value for the id. Sometimes the id of a stateless service instance is also referred as a replica id."
    },
    "ReplicaOrInstanceId": {
      "type": "string",
      "description": "Id of a stateful service replica or a stateless service instance. This id is used in the queries that apply to both stateful and stateless services. It is used by Service Fabric to uniquely identify a replica of a partition of a stateful service or an instance of a stateless service partition. It is unique within a partition and does not change for the lifetime of the replica or the instance. If a stateful replica gets dropped and another replica gets created on the same node for the same partition, it will get a different value for the id. If a staless instance is failed over on the same or different node it will get a different value for the id."
    },
    "ReplicaInfo": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "Information about the identity, status, health, node name, uptime, and other details about the replica.",
      "required": [
        "ServiceKind"
      ],
      "properties": {
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "ReplicaStatus": {
          "$ref": "#/definitions/ReplicaStatus"
        },
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "NodeName": {
          "$ref": "#/definitions/NodeName"
        },
        "Address": {
          "type": "string",
          "description": "The address the replica is listening on."
        },
        "LastInBuildDurationInSeconds": {
          "type": "string",
          "description": "The last in build duration of the replica in seconds."
        }
      }
    },
    "ReplicaRole": {
      "type": "string",
      "description": "The role of a replica of a stateful service. Possible values are following.\n  - Unknown - Indicates the initial role that a replica is created in. The value is zero.\n  - None - Specifies that the replica has no responsibility in regard to the replica set. The value is 1\n  - Primary - Refers to the replica in the set on which all read and write operations are complete in order to enforce strong consistency semantics. Read operations are handled directly by the Primary replica, while write operations must be acknowledged by a quorum of the replicas in the replica set. There can only be one Primary replica in a replica set at a time. The value is 2.\n  - IdleSecondary - Refers to a replica in the set that receives a state transfer from the Primary replica to prepare for becoming an active Secondary replica. There can be multiple Idle Secondary replicas in a replica set at a time. Idle Secondary replicas do not count as a part of a write quorum. The value is 3.\n  - ActiveSecondary - Refers to a replica in the set that receives state updates from the Primary replica, applies them, and sends acknowledgements back. Secondary replicas must participate in the write quorum for a replica set. There can be multiple active Secondary replicas in a replica set at a time. The number of active Secondary replicas is configurable that the reliability subsystem should maintain. The value is 4.\n",
      "enum": [
        "Unknown",
        "None",
        "Primary",
        "IdleSecondary",
        "ActiveSecondary"
      ]
    },
    "ReplicasHealthEvaluation": {
      "x-ms-discriminator-value": "Replicas",
      "description": "Represents health evaluation for replicas, containing health evaluations for each unhealthy replica that impacted current aggregated health state. Can be returned when evaluating partition health and the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ReplicasHealthEvaluation",
          "properties": {
            "MaxPercentUnhealthyReplicasPerPartition": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy replicas per partition from the ApplicationHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of replicas in the partition from the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ReplicaStatus": {
      "type": "string",
      "description": "The status of a replica of a service. Possible values are following.\n\n  -Invalid - Indicates the replica status is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  -InBuild - The replica is being built. This means that a primary replica is seeding this replica. The value is 1.\n  -Standby - The replica is in standby. The value is 2.\n  -Ready - The replica is ready. The value is 3.\n  -Down - The replica is down. The value is 4.\n  -Dropped - Replica is dropped. This means that the replica has been removed from the replica set. If it is persisted, its state has been deleted. The value is 5.\n",
      "enum": [
        "Invalid",
        "InBuild",
        "Standby",
        "Ready",
        "Down",
        "Dropped"
      ]
    },
    "RestartNodeDescription": {
      "description": "Describes the parameters to restart a Service Fabric node.",
      "properties": {
        "NodeInstanceId": {
          "type": "string",
          "description": "The instance id of the target node. If instance id is specified the node is restarted only if it matches with the current instance of the node. A default value of \"0\" would match any instance id. The instance id can be obtained using get node query.",
          "default": "0"
        },
        "CreateFabricDump": {
          "type": "string",
          "description": "Specify True to create a dump of the fabric node process. This is case sensitive.",
          "enum": [
            "False",
            "True"
          ],
          "default": "False"
        }
      },
      "required": [
        "NodeInstanceId"
      ]
    },
    "SafetyCheckInfoList": {
      "type": "array",
      "description": "List of pending safety checks",
      "items": {
        "$ref": "#/definitions/SafetyCheckWrapper"
      }
    },
    "SafetyCheckWrapper": {
      "type": "object",
      "description": "A wrapper for the safety check object. Safety checks are performed by service fabric before continuing with the operations. These checks ensure the availability of the service and the reliability of the state.",
      "properties": {
        "SafetyCheck": {
          "$ref": "#/definitions/SafetyCheck"
        }
      }
    },
    "ServiceFromTemplateDescription": {
      "type": "object",
      "description": "Defines description for creating a Service Fabric service from a template defined in the application manifest.\n",
      "required": [
        "ApplicationName",
        "ServiceName",
        "ServiceTypeName"
      ],
      "properties": {
        "ApplicationName": {
          "$ref": "#/definitions/ApplicationName"
        },
        "ServiceName": {
          "$ref": "#/definitions/ServiceName"
        },
        "ServiceTypeName": {
          "$ref": "#/definitions/ServiceTypeName"
        },
        "InitializationData": {
          "$ref": "#/definitions/ByteArray"
        },
        "ServicePackageActivationMode": {
          "$ref": "#/definitions/ServicePackageActivationMode"
        },
        "ServiceDnsName": {
          "type": "string",
          "description": "The DNS name of the service. It requires the DNS system service to be enabled in Service Fabric cluster."
        }
      }
    },
    "ServiceHealthEvaluation": {
      "x-ms-discriminator-value": "Service",
      "description": "Represents health evaluation for a service, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ServiceHealthEvaluation",
          "properties": {
            "ServiceName": {
              "$ref": "#/definitions/ServiceName"
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ServiceHealthState": {
      "description": "Represents the health state of a service, which contains the service identifier and its aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthState"
        },
        {
          "type": "object",
          "description": "ServiceHealthState",
          "properties": {
            "ServiceName": {
              "$ref": "#/definitions/ServiceName"
            }
          }
        }
      ]
    },
    "ServiceHealthStateChunk": {
      "description": "Represents the health state chunk of a service, which contains the service name, its aggregated health state and any partitions that respect the filters in the cluster health chunk query description.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealthStateChunk"
        },
        {
          "type": "object",
          "description": "ServiceHealthStateChunk",
          "properties": {
            "ServiceName": {
              "$ref": "#/definitions/ServiceName"
            },
            "PartitionHealthStateChunks": {
              "$ref": "#/definitions/PartitionHealthStateChunkList"
            }
          }
        }
      ]
    },
    "ServiceHealthStateChunkList": {
      "type": "object",
      "description": "The list of service health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.\n",
      "properties": {
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ServiceHealthStateChunk"
          },
          "description": "The list of service health state chunks that respect the input filters in the chunk query.\n"
        }
      }
    },
    "ServiceHealthStateFilter": {
      "type": "object",
      "description": "Defines matching criteria to determine whether a service should be included as a child of an application in the cluster health chunk.\nThe services are only returned if the parent application matches a filter specified in the cluster health chunk query description.\nOne filter can match zero, one or multiple services, depending on its properties.\n",
      "properties": {
        "ServiceNameFilter": {
          "type": "string",
          "description": "The name of the service that matches the filter. The filter is applied only to the specified service, if it exists.\nIf the service doesn't exist, no service is returned in the cluster health chunk based on this filter.\nIf the service exists, it is included as the application's child if the health state matches the other filter properties.\nIf not specified, all services that match the parent filters (if any) are taken into consideration and matched against the other filter members, like health state filter.\n"
        },
        "HealthStateFilter": {
          "type": "integer",
          "default": 0,
          "description": "The filter for the health state of the services. It allows selecting services if they match the desired health states.\nThe possible values are integer value of one of the following health states. Only services that match the filter are returned. All services are used to evaluate the cluster aggregated health state.\nIf not specified, default value is None, unless the service name is specified. If the filter has default value and service name is specified, the matching service is returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6, it matches services with HealthState value of OK (2) and Warning (4).\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n"
        },
        "PartitionFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PartitionHealthStateFilter"
          },
          "description": "Defines a list of filters that specify which partitions to be included in the returned cluster health chunk as children of the service. The partitions are returned only if the parent service matches a filter.\nIf the list is empty, no partitions are returned. All the partitions are used to evaluate the parent service aggregated health state, regardless of the input filters.\nThe service filter may specify multiple partition filters.\nFor example, it can specify a filter to return all partitions with health state Error and another filter to always include a partition identified by its partition id.\n"
        }
      }
    },
    "ServiceHealth": {
      "description": "Information about the health of a Service Fabric service.",
      "allOf": [
        {
          "$ref": "#/definitions/EntityHealth"
        },
        {
          "type": "object",
          "description": "ServiceHealth",
          "properties": {
            "Name": {
              "$ref": "#/definitions/ServiceName"
            },
            "PartitionHealthStates": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/PartitionHealthState"
              },
              "description": "The list of partition health states associated with the service."
            }
          }
        }
      ]
    },
    "ServiceId": {
      "type": "string",
      "description": "The identity of the service. This is an encoded representation of the service name. This is used in the REST APIs to identify the service resource.\n\nStarting in version 6.0, hierarchical names are delimited with the \"~\" character. For example, if the service name is \"fabric://myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions.\n"
    },
    "ServiceName": {
      "type": "string",
      "description": "The full name of the service with 'fabric:' URI scheme."
    },
    "ServiceManifestName": {
      "type": "string",
      "description": "The name of the service manifest."
    },
    "ServiceTypeName": {
      "type": "string",
      "description": "Name of the service type as specified in the service manifest."
    },
    "ServiceInfo": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "Information about a Service Fabric service.",
      "properties": {
        "Id": {
          "$ref": "#/definitions/ServiceId"
        },
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "Name": {
          "$ref": "#/definitions/ServiceName"
        },
        "TypeName": {
          "$ref": "#/definitions/ServiceTypeName"
        },
        "ManifestVersion": {
          "description": "The version of the service manifest.",
          "type": "string"
        },
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "ServiceStatus": {
          "$ref": "#/definitions/ServiceStatus"
        },
        "IsServiceGroup": {
          "description": "Whether the service is in a service group.",
          "type": "boolean"
        }
      },
      "required": [
        "ServiceKind"
      ]
    },
    "ServiceKind": {
      "type": "string",
      "description": "The kind of service (Stateless or Stateful). Following are the possible values.\n\n- Invalid - Indicates the service kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n- Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1.\n- Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.\n",
      "enum": [
        "Invalid",
        "Stateless",
        "Stateful"
      ]
    },
    "ServiceNameInfo": {
      "type": "object",
      "description": "Information about the service name.",
      "properties": {
        "Id": {
          "$ref": "#/definitions/ServiceId"
        },
        "Name": {
          "$ref": "#/definitions/ServiceName"
        }
      }
    },
    "ServicePackageActivationId": {
      "type": "string",
      "description": "The ActivationId of a deployed service package. If ServicePackageActivationMode specified at the time of creating the service\nis 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'), then value of ServicePackageActivationId\nis always an empty string.\n"
    },
    "ServicePartitionInfo": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "Information about a partition of a Service Fabric service.",
      "required": [
        "ServiceKind"
      ],
      "properties": {
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "HealthState": {
          "$ref": "#/definitions/HealthState"
        },
        "PartitionStatus": {
          "$ref": "#/definitions/ServicePartitionStatus"
        },
        "PartitionInformation": {
          "$ref": "#/definitions/PartitionInformation"
        }
      }
    },
    "ServicePartitionKind": {
      "type": "string",
      "description": "The kind of partitioning scheme used to partition the service. Possible values are following.\n\n    -\tInvalid - Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    -\tSingleton - Indicates that there is only one partition, and SingletonPartitionSchemeDescription was specified while creating the service. The value is 1.\n    -\tInt64Range - Indicates that the partition is based on Int64 key ranges, and UniformInt64RangePartitionSchemeDescription was specified while creating the service. The value is 2.\n    -\tNamed - Indicates that the partition is based on string names, and NamedPartitionInformation  was specified while creating the service. The value is 3.\n",
      "enum": [
        "Invalid",
        "Singleton",
        "Int64Range",
        "Named"
      ]
    },
    "ServicePartitionStatus": {
      "type": "string",
      "description": "The status of the service fabric service partition. Possible values are following.\n\n  - Invalid - Indicates the partition status is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Ready - Indicates that the partition is ready. This means that for a stateless service partition there is atleast one instance that is up and for a stateful service partition the number of ready replicas is greater than or equal to the MinReplicaSetSize. The value is 1.\n  - NotReady - Indicates that the partition is not ready. This status is returned when none of the other states apply. The value is 2.\n  - InQuorumLoss  - Indicates that the partition is in quorum loss. This means that number of replicas that are up and participating in a replica set is less than MinReplicaSetSize for this partition. The value is 3.\n  - Reconfiguring - Indicates that the partition is undergoing reconfiguration of its replica sets. This can happen due to failover, upgrade, load balancing or addition or removal of replicas from the replica set. The value is 4.\n  - Deleting - Indicates that the partition is being deleted. The value is 5.\n",
      "enum": [
        "Invalid",
        "Ready",
        "NotReady",
        "InQuorumLoss",
        "Reconfiguring",
        "Deleting"
      ]
    },
    "ServicePlacementInvalidDomainPolicyDescription": {
      "x-ms-discriminator-value": "InvalidDomain",
      "description": "Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePlacementPolicyDescription"
        },
        {
          "type": "object",
          "description": "ServicePlacementInvalidDomainPolicyDescription",
          "properties": {
            "DomainName": {
              "type": "string",
              "description": "The name of the domain that should not be used for placement."
            }
          }
        }
      ]
    },
    "ServicePlacementNonPartiallyPlaceServicePolicyDescription": {
      "x-ms-discriminator-value": "NonPartiallyPlaceService",
      "description": "Describes the policy to be used for placement of a Service Fabric service where all replicas must be able to be placed in order for any replicas to be created.\n",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePlacementPolicyDescription"
        },
        {
          "type": "object",
          "description": "ServicePlacementNonPartiallyPlaceServicePolicyDescription"
        }
      ]
    },
    "ServicePlacementPolicyDescription": {
      "type": "object",
      "discriminator": "Type",
      "description": "Describes the policy to be used for placement of a Service Fabric service.",
      "required": [
        "Type"
      ],
      "properties": {
        "Type": {
          "$ref": "#/definitions/ServicePlacementPolicyType"
        }
      }
    },
    "ServicePlacementPolicyDescriptionList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServicePlacementPolicyDescription"
      },
      "description": "List of service placement policy descriptions."
    },
    "ServicePlacementPolicyType": {
      "type": "string",
      "description": "The type of placement policy for a service fabric service. Following are the possible values.\n\n  - Invalid - Indicates the type of the placement policy is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - InvalidDomain - Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementInvalidDomainPolicyDescription, which indicates that a particular fault or upgrade domain cannot be used for placement of this service. The value is 1.\n  - RequiredDomain - Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription indicating that the replicas of the service must be placed in a specific domain. The value is 2.\n  - PreferredPrimaryDomain - Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that if possible the Primary replica for the partitions of the service should be located in a particular domain as an optimization. The value is 3.\n  - RequiredDomainDistribution - Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription, indicating that the system will disallow placement of any two replicas from the same partition in the same domain at any time. The value is 4.\n  - NonPartiallyPlaceService - Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates that if possible all replicas of a particular partition of the service should be placed atomically. The value is 5.\n",
      "enum": [
        "Invalid",
        "InvalidDomain",
        "RequiredDomain",
        "PreferredPrimaryDomain",
        "RequiredDomainDistribution",
        "NonPartiallyPlaceService"
      ]
    },
    "ServicePlacementPreferPrimaryDomainPolicyDescription": {
      "x-ms-discriminator-value": "PreferPrimaryDomain",
      "description": "Describes the policy to be used for placement of a Service Fabric service where the service's Primary replicas should optimally be placed in a particular domain.\n\nThis placement policy is usually used with fault domains in scenarios where the Service Fabric cluster is geographically distributed in order to indicate that a service's primary replica should be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica may not end up located in this domain due to failures, capacity limits, or other constraints.\n",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePlacementPolicyDescription"
        },
        {
          "type": "object",
          "description": "ServicePlacementPreferPrimaryDomainPolicyDescription",
          "properties": {
            "DomainName": {
              "type": "string",
              "description": "The name of the domain that should used for placement as per this policy."
            }
          }
        }
      ]
    },
    "ServicePlacementRequiredDomainPolicyDescription": {
      "x-ms-discriminator-value": "RequireDomain",
      "description": "Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePlacementPolicyDescription"
        },
        {
          "type": "object",
          "description": "ServicePlacementRequiredDomainPolicyDescription",
          "properties": {
            "DomainName": {
              "type": "string",
              "description": "The name of the domain that should used for placement as per this policy."
            }
          }
        }
      ]
    },
    "ServicePlacementRequireDomainDistributionPolicyDescription": {
      "x-ms-discriminator-value": "RequireDomainDistribution",
      "description": "Describes the policy to be used for placement of a Service Fabric service where two replicas from the same partition should never be placed in the same fault or upgrade domain.\n\nWhile this is not common it can expose the service to an increased risk of concurrent failures due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider a case where replicas are deployed across different data center, with one replica per location. In the event that one of the datacenters goes offline, normally the replica that was placed in that datacenter will be packed into one of the remaining datacenters. If this is not desirable then this policy should be set.\n",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePlacementPolicyDescription"
        },
        {
          "type": "object",
          "description": "ServicePlacementRequireDomainDistributionPolicyDescription",
          "properties": {
            "DomainName": {
              "type": "string",
              "description": "The name of the domain that should used for placement as per this policy."
            }
          }
        }
      ]
    },
    "ServicesHealthEvaluation": {
      "x-ms-discriminator-value": "Services",
      "description": "Represents health evaluation for services of a certain service type belonging to an application, containing health evaluations for each unhealthy service that impacted current aggregated health state. Can be returned when evaluating application health and the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "ServicesHealthEvaluation",
          "properties": {
            "ServiceTypeName": {
              "type": "string",
              "description": "Name of the service type of the services."
            },
            "MaxPercentUnhealthyServices": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy services from the ServiceTypeHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of services of the current service type in the application from the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "ServiceStatus": {
      "type": "string",
      "description": "The status of the application. Possible values are:\n\n- Unknown - Indicates the service status is unknown. The value is zero.\n- Active - Indicates the service status is active. The value is 1.\n- Upgrading - Indicates the service is upgrading. The value is 2.\n- Deleting - Indicates the service is being deleted. The value is 3.\n- Creating - Indicates the service is being created. The value is 4.\n- Failed - Indicates creation or deletion was terminated due to persistent failures. Another create/delete request can be accepted. The value is 5.\n",
      "enum": [
        "Unknown",
        "Active",
        "Upgrading",
        "Deleting",
        "Creating",
        "Failed"
      ]
    },
    "ServiceTypeDescription": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Describes a service type defined in the service manifest of a provisioned application type. The properties the the ones defined in the service manifest.",
      "required": [
        "Kind"
      ],
      "properties": {
        "Kind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "IsStateful": {
          "type": "boolean",
          "description": "Indicates whether the service type is a stateful service type or a stateless service type. This property is true if the service type is a stateful service type, false otherwise."
        },
        "ServiceTypeName": {
          "$ref": "#/definitions/ServiceTypeName"
        },
        "PlacementConstraints": {
          "type": "string",
          "description": "The placement constraint to be used when instantiating this service in a Service Fabric cluster."
        },
        "ServicePlacementPolicies": {
          "$ref": "#/definitions/ServicePlacementPolicyDescriptionList"
        },
        "Extensions": {
          "$ref": "#/definitions/ServiceTypeExtensionDescriptionList"
        }
      }
    },
    "ServiceTypeExtensionDescription": {
      "type": "object",
      "description": "Describes extension of a service type defined in the service manifest.",
      "properties": {
        "Key": {
          "type": "string",
          "description": "The name of the extension."
        },
        "Value": {
          "type": "string",
          "description": "The extension value."
        }
      }
    },
    "ServiceTypeExtensionDescriptionList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServiceTypeExtensionDescription"
      },
      "description": "List of service type extensions."
    },
    "ServiceTypeHealthPolicy": {
      "type": "object",
      "description": "Represents the health policy used to evaluate the health of services belonging to a service type.\n",
      "properties": {
        "MaxPercentUnhealthyPartitionsPerService": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy partitions per service. Allowed values are Byte values from zero to 100\n\nThe percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.\nIf the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.\nThe percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.\nThe computation rounds up to tolerate one failure on small numbers of partitions. Default percentage is zero.\n",
          "default": 0
        },
        "MaxPercentUnhealthyReplicasPerPartition": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy replicas per partition. Allowed values are Byte values from zero to 100.\n\nThe percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.\nIf the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.\nThe percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.\nThe computation rounds up to tolerate one failure on small numbers of replicas. Default percentage is zero.\n",
          "default": 0
        },
        "MaxPercentUnhealthyServices": {
          "type": "integer",
          "description": "The maximum maximum allowed percentage of unhealthy services. Allowed values are Byte values from zero to 100.\n\nThe percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.\nIf the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.\nThis is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.\nThe computation rounds up to tolerate one failure on small numbers of services. Default percentage is zero.\n",
          "default": 0
        }
      }
    },
    "ServiceTypeHealthPolicyMap": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServiceTypeHealthPolicyMapItem"
      },
      "description": "Defines a ServiceTypeHealthPolicy per service type name.\n\nThe entries in the map replace the default service type health policy for each specified service type. For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently. With policy per service type, there's more granular control of the health of the service.\n\nIf no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.\n"
    },
    "ServiceTypeHealthPolicyMapItem": {
      "type": "object",
      "description": "Defines an item in ServiceTypeHealthPolicyMap.\n",
      "required": [
        "Key",
        "Value"
      ],
      "properties": {
        "Key": {
          "type": "string",
          "description": "The key of the service type health policy map item. This is the name of the service type."
        },
        "Value": {
          "$ref": "#/definitions/ServiceTypeHealthPolicy"
        }
      }
    },
    "ServiceTypeInfo": {
      "type": "object",
      "description": "Information about a service type that is defined in a service manifest of a provisioned application type.",
      "properties": {
        "ServiceTypeDescription": {
          "$ref": "#/definitions/ServiceTypeDescription"
        },
        "ServiceManifestName": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "ServiceManifestVersion": {
          "type": "string",
          "description": "The version of the service manifest in which this service type is defined."
        },
        "IsServiceGroup": {
          "type": "boolean",
          "description": "Indicates whether the service is a service group. If it is, the property value is true otherwise false."
        }
      }
    },
    "ServiceTypeInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServiceTypeInfo"
      },
      "description": "List of service type information."
    },
    "ServiceTypeManifest": {
      "type": "object",
      "description": "Contains the manifest describing a service type registered as part of an application in a Service Fabric cluster.",
      "properties": {
        "Manifest": {
          "type": "string",
          "description": "The XML manifest as a string."
        }
      }
    },
    "SingletonPartitionInformation": {
      "description": "Information about a partition that is singleton. The services with singletone partitioning scheme are effectively non-partitioned. They only have one partition.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionInformation"
        },
        {
          "type": "object",
          "description": "StatelessServicePartitionInfo"
        }
      ],
      "x-ms-discriminator-value": "Singleton"
    },
    "StatefulServiceInfo": {
      "description": "Information about a stateful Service Fabric service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceInfo"
        },
        {
          "type": "object",
          "description": "StatefulService",
          "properties": {
            "HasPersistedState": {
              "description": "Whether the service has persisted state.",
              "type": "boolean"
            }
          }
        }
      ],
      "x-ms-discriminator-value": "Stateful"
    },
    "StatefulServicePartitionInfo": {
      "description": "Information about a partition of a stateful Service Fabric service..",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePartitionInfo"
        },
        {
          "type": "object",
          "description": "StatefulServicePartitionInfo"
        }
      ],
      "x-ms-discriminator-value": "Stateful",
      "properties": {
        "TargetReplicaSetSize": {
          "type": "integer",
          "format": "int64",
          "description": "The target replica set size as a number."
        },
        "MinReplicaSetSize": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum replica set size as a number."
        },
        "LastQuorumLossDuration": {
          "type": "string",
          "format": "duration",
          "description": "The duration for which this partition was in quorum loss. If the partition is currently in quorum loss, it returns the duration since it has been in that state. This field is using ISO8601 format for specifying the duration."
        },
        "CurrentConfigurationEpoch": {
          "$ref": "#/definitions/Epoch"
        }
      }
    },
    "StatefulServiceReplicaHealth": {
      "description": "Represents the health of the stateful service replica.\nContains the replica aggregated health state, the health events and the unhealthy evaluations.\n",
      "x-ms-discriminator-value": "Stateful",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaHealth"
        },
        {
          "type": "object",
          "description": "StatefulServiceReplicaHealth",
          "properties": {
            "ReplicaId": {
              "$ref": "#/definitions/ReplicaId"
            }
          }
        }
      ]
    },
    "StatefulServiceReplicaHealthState": {
      "x-ms-discriminator-value": "Stateful",
      "description": "Represents the health state of the stateful service replica, which contains the replica id and the aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaHealthState"
        },
        {
          "type": "object",
          "description": "StatefulServiceReplicaHealthState",
          "properties": {
            "ReplicaId": {
              "$ref": "#/definitions/ReplicaId"
            }
          }
        }
      ]
    },
    "StatefulServiceTypeDescription": {
      "description": "Describes a stateful service type defined in the service manifest of a provisioned application type.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceTypeDescription"
        },
        {
          "type": "object",
          "description": "StatefulServiceTypeDescription"
        }
      ],
      "x-ms-discriminator-value": "Stateful",
      "properties": {
        "HasPersistedState": {
          "type": "boolean",
          "description": "A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false."
        }
      }
    },
    "StatelessServiceInfo": {
      "description": "Information about a stateless Service Fabric service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceInfo"
        },
        {
          "type": "object",
          "description": "StatelessService"
        }
      ],
      "x-ms-discriminator-value": "Stateless"
    },
    "StatelessServiceInstanceHealth": {
      "description": "Represents the health of the statelss service instance.\nContains the instance aggregated health state, the health events and the unhealthy evaluations.\n",
      "x-ms-discriminator-value": "Stateless",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaHealth"
        },
        {
          "type": "object",
          "description": "StatelessServiceInstanceHealth",
          "properties": {
            "InstanceId": {
              "$ref": "#/definitions/InstanceId"
            }
          }
        }
      ]
    },
    "StatelessServiceInstanceHealthState": {
      "x-ms-discriminator-value": "Stateless",
      "description": "Represents the health state of the stateless service instance, which contains the instance id and the aggregated health state.",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaHealthState"
        },
        {
          "type": "object",
          "description": "StatelessServiceInstanceHealthState",
          "properties": {
            "ReplicaId": {
              "$ref": "#/definitions/ReplicaId"
            }
          }
        }
      ]
    },
    "StatelessServicePartitionInfo": {
      "description": "Information about a partition of a stateless Service Fabric service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServicePartitionInfo"
        },
        {
          "type": "object",
          "description": "StatelessServicePartitionInfo"
        }
      ],
      "x-ms-discriminator-value": "Stateless",
      "properties": {
        "InstanceCount": {
          "type": "integer",
          "format": "int64",
          "description": "Number of instances of this partition."
        }
      }
    },
    "StatelessServiceTypeDescription": {
      "description": "Describes a stateless service type defined in the service manifest of a provisioned application type.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceTypeDescription"
        },
        {
          "type": "object",
          "description": "StatelessServiceTypeDescription"
        }
      ],
      "x-ms-discriminator-value": "Stateless",
      "properties": {
        "UseImplicitHost": {
          "type": "boolean",
          "description": "A flag indicating if this type is not implemented and hosted by a user service process, but is implicitly hosted by a system created process. This value is true for services using the guest executable services, false otherwise."
        }
      }
    },
    "SystemApplicationHealthEvaluation": {
      "x-ms-discriminator-value": "SystemApplication",
      "description": "Represents health evaluation for the fabric:/System application, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state of the cluster is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "SystemApplicationHealthEvaluation",
          "properties": {
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "TargetApplicationName": {
      "type": "string",
      "description": "The name of the target application, including the 'fabric:' URI scheme."
    },
    "TargetApplicationTypeVersion": {
      "type": "string",
      "description": "The target application type version (found in the application manifest) for the application upgrade."
    },
    "TargetDeploymentName": {
      "type": "string",
      "description": "The name of the target deployment."
    },
    "UnhealthyEvaluations": {
      "description": "List of health evaluations that resulted in the current aggregated health state.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/HealthEvaluationWrapper"
      }
    },
    "UpgradeDomainDeltaNodesCheckHealthEvaluation": {
      "x-ms-discriminator-value": "UpgradeDomainDeltaNodesCheck",
      "description": "Represents health evaluation for delta unhealthy cluster nodes in an upgrade domain, containing health evaluations for each unhealthy node that impacted current aggregated health state.\nCan be returned during cluster upgrade when cluster aggregated health state is Warning or Error.\n",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "UpgradeDomainDeltaNodesCheckHealthEvaluation",
          "properties": {
            "UpgradeDomainName": {
              "type": "string",
              "description": "Name of the upgrade domain where nodes health is currently evaluated."
            },
            "BaselineErrorCount": {
              "type": "integer",
              "format": "int64",
              "description": "Number of upgrade domain nodes with aggregated heath state Error in the health store at the beginning of the cluster upgrade."
            },
            "BaselineTotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of upgrade domain nodes in the health store at the beginning of the cluster upgrade."
            },
            "MaxPercentDeltaUnhealthyNodes": {
              "type": "integer",
              "description": "Maximum allowed percentage of upgrade domain delta unhealthy nodes from the ClusterUpgradeHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of upgrade domain nodes in the health store."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "UpgradeDomainInfo": {
      "type": "object",
      "description": "Information about an upgrade domain.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/UpgradeDomainName"
        },
        "State": {
          "$ref": "#/definitions/UpgradeDomainState"
        }
      }
    },
    "UpgradeDomainInfoList": {
      "type": "array",
      "description": "List of upgrade domains and their statuses.",
      "items": {
        "$ref": "#/definitions/UpgradeDomainInfo"
      }
    },
    "UpgradeDomainName": {
      "type": "string",
      "description": "The name of the upgrade domain"
    },
    "UpgradeDomainNodesHealthEvaluation": {
      "x-ms-discriminator-value": "UpgradeDomainNodes",
      "description": "Represents health evaluation for cluster nodes in an upgrade domain, containing health evaluations for each unhealthy node that impacted current aggregated health state. Can be returned when evaluating cluster health during cluster upgrade and the aggregated health state is either Error or Warning.",
      "allOf": [
        {
          "$ref": "#/definitions/HealthEvaluation"
        },
        {
          "type": "object",
          "description": "UpgradeDomainNodesHealthEvaluation",
          "properties": {
            "UpgradeDomainName": {
              "type": "string",
              "description": "Name of the upgrade domain where nodes health is currently evaluated."
            },
            "MaxPercentUnhealthyNodes": {
              "type": "integer",
              "description": "Maximum allowed percentage of unhealthy nodes from the ClusterHealthPolicy."
            },
            "TotalCount": {
              "type": "integer",
              "format": "int64",
              "description": "Total number of nodes in the current upgrade domain."
            },
            "UnhealthyEvaluations": {
              "$ref": "#/definitions/UnhealthyEvaluations"
            }
          }
        }
      ]
    },
    "UpgradeDomainState": {
      "type": "string",
      "description": "The state of the upgrade domain.\n\n    - Invalid - Indicates the upgrade domain state is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - Pending - The upgrade domain has not started upgrading yet. The value is 1\n    - InProgress - The upgrade domain is being upgraded but not complete yet. The value is 2\n    - Completed - The upgrade domain has completed upgrade. The value is 3\n",
      "enum": [
        "Invalid",
        "Pending",
        "InProgress",
        "Completed"
      ]
    },
    "UpgradeDomainTimeout": {
      "type": "string",
      "description": "The amount of time each upgrade domain has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "P10675199DT02H48M05.4775807S"
    },
    "UpgradeDuration": {
      "type": "string",
      "description": "The estimated amount of time that the overall upgrade elapsed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "PT0H2M0S"
    },
    "UpgradeKind": {
      "type": "string",
      "description": "The kind of upgrade out of the following possible values.\n\n    - Invalid - Indicates the upgrade kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - Rolling - The upgrade progresses one upgrade domain at a time. The value is 1\n",
      "default": "Rolling",
      "enum": [
        "Invalid",
        "Rolling"
      ]
    },
    "UpgradeMode": {
      "type": "string",
      "description": "The mode used to monitor health during a rolling upgrade.\n\n    - Invalid - Indicates the upgrade mode is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - UnmonitoredAuto - The upgrade will proceed automatically without performing any health monitoring. The value is 1\n    - UnmonitoredManual - The upgrade will stop after completing each upgrade domain, giving the opportunity to manually monitor health before proceeding. The value is 2\n    - Monitored - The upgrade will stop after completing each upgrade domain and automatically monitor health before proceeding. The value is 3\n",
      "enum": [
        "Invalid",
        "UnmonitoredAuto",
        "UnmonitoredManual",
        "Monitored"
      ],
      "default": "UnmonitoredAuto"
    },
    "UpgradeType": {
      "type": "string",
      "description": "The type of upgrade out of the following possible values.\n\n    - Invalid - Indicates the upgrade kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - Rolling - The upgrade progresses one upgrade domain at a time. The value is 1.\n    - Rolling_ForceRestart - The upgrade gets restarted by force. The value is 2.\n",
      "default": "Rolling",
      "enum": [
        "Invalid",
        "Rolling",
        "Rolling_ForceRestart"
      ]
    },
    "UpgradeReplicaSetCheckTimeout": {
      "type": "integer",
      "format": "int64",
      "description": "The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).",
      "default": 42949672925
    },
    "UpgradeState": {
      "type": "string",
      "description": "The state of the upgrade domain.\n\n    - Invalid - Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - RollingBackInProgress - The upgrade is rolling back to the previous version but is not complete yet. The value is 1\n    - RollingBackCompleted - The upgrade has finished rolling back. The value is 2\n    - RollingForwardPending - The current upgrade domain has finished upgrading. The overall upgrade is waiting for an explicit move next request in UnmonitoredManual mode or performing health checks in Monitored mode. The value is 3\n    - RollingForwardInProgress - The upgrade is rolling forward to the target version but is not complete yet. The value is 4\n    - RollingForwardCompleted - The upgrade has finished rolling forward. The value is 5\n    - Failed - The upgrade has failed and is unable to execute FailureAction. The value is 6\n",
      "enum": [
        "Invalid",
        "RollingBackInProgress",
        "RollingBackCompleted",
        "RollingForwardPending",
        "RollingForwardInProgress",
        "RollingForwardCompleted",
        "Failed"
      ]
    },
    "UpgradeTimeout": {
      "type": "string",
      "description": "The amount of time the overall upgrade has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.",
      "default": "P10675199DT02H48M05.4775807S"
    },
    "WaitForInbuildReplicaSafetyCheck": {
      "description": "Safety check that waits for the replica build operation to finish. This indiciates that there is a replica that is going through the copy or is providing data for building another replica. Bring the node down will abort this copy operation which are typoically expensive involving data movements.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSafetyCheck"
        },
        {
          "type": "object",
          "description": "WaitForInbuildReplicaSafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "WaitForInbuildReplica"
    },
    "WaitForPrimaryPlacementSafetyCheck": {
      "description": "Safety check that waits for the primary replica that was moved out of the node due to upgrade to be placed back again on that node.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSafetyCheck"
        },
        {
          "type": "object",
          "description": "WaitForPrimaryPlacementSafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "WaitForPrimaryPlacement"
    },
    "WaitForPrimarySwapSafetyCheck": {
      "description": "Safety check that waits for the primary replica to be moved out of the node before starting an upgrade to ensure the availability of the primary replica for the partition.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSafetyCheck"
        },
        {
          "type": "object",
          "description": "WaitForPrimarySwapSafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "WaitForPrimarySwap"
    },
    "WaitForReconfigurationSafetyCheck": {
      "description": "Safety check that waits for the current reconfiguration of the partition to be completed before starting an upgrade.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSafetyCheck"
        },
        {
          "type": "object",
          "description": "WaitForReconfigurationSafetyCheck"
        }
      ],
      "x-ms-discriminator-value": "WaitForReconfiguration"
    },
    "LoadMetricReport": {
      "type": "object",
      "description": "Represents the load metric report which contains the time metric was reported, its name and value.",
      "properties": {
        "LastReportedUtc": {
          "type": "string",
          "format": "date-time",
          "description": "Gets the UTC time when the load was reported."
        },
        "Name": {
          "type": "string",
          "description": "The name of the load metric."
        },
        "Value": {
          "type": "string",
          "format": "int32",
          "description": "The value of the load metric."
        }
      }
    },
    "PartitionLoadInformation": {
      "type": "object",
      "description": "Represents load information for a partition, which contains the primary and secondary reported load metrics.\nIn case there is no load reported, PartitionLoadInformation will contain the default load for the service of the partition.\nFor default loads, LoadMetricReport's LastReportedUtc is set to 0.\n",
      "properties": {
        "PartitionId": {
          "$ref": "#/definitions/PartitionId"
        },
        "PrimaryLoadMetricReports": {
          "type": "array",
          "description": "Array of load reports from the primary replica for this partition.",
          "items": {
            "$ref": "#/definitions/LoadMetricReport"
          }
        },
        "SecondaryLoadMetricReports": {
          "type": "array",
          "description": "Array of aggregated load reports from all secondary replicas for this partition.\nArray only contains the latest reported load for each metric.\n",
          "items": {
            "$ref": "#/definitions/LoadMetricReport"
          }
        }
      }
    },
    "StatefulServiceReplicaInfo": {
      "x-ms-discriminator-value": "Stateful",
      "description": "Represents a stateful service replica. This includes information about the identity, role, status, health, node name, uptime, and other details about the replica.",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaInfo"
        },
        {
          "type": "object",
          "description": "StatefulServiceReplicaInfo",
          "properties": {
            "ReplicaRole": {
              "$ref": "#/definitions/ReplicaRole"
            },
            "ReplicaId": {
              "$ref": "#/definitions/ReplicaId"
            }
          }
        }
      ]
    },
    "StatelessServiceInstanceInfo": {
      "x-ms-discriminator-value": "Stateless",
      "description": "Represents a stateless service instance. This includes information about the identity, status, health, node name, uptime, and other details about the instance.",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaInfo"
        },
        {
          "type": "object",
          "description": "StatelessServiceInstanceInfo",
          "properties": {
            "InstanceId": {
              "$ref": "#/definitions/InstanceId"
            }
          }
        }
      ]
    },
    "ClusterFabricCodeVersionString": {
      "type": "string",
      "description": "The ServiceFabric code version of the cluster."
    },
    "ClusterFabricConfigVersionString": {
      "type": "string",
      "description": "The cluster configuration version (specified in the cluster manifest)."
    },
    "ClusterUpgradeDescriptionObject": {
      "type": "object",
      "description": "Represents a ServiceFabric cluster upgrade",
      "properties": {
        "ConfigVersion": {
          "$ref": "#/definitions/ClusterFabricConfigVersionString"
        },
        "CodeVersion": {
          "$ref": "#/definitions/ClusterFabricCodeVersionString"
        },
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeKind"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "UpgradeReplicaSetCheckTimeoutInSeconds": {
          "$ref": "#/definitions/UpgradeReplicaSetCheckTimeout"
        },
        "ForceRestart": {
          "$ref": "#/definitions/ForceRestart"
        },
        "EnableDeltaHealthEvaluation": {
          "$ref": "#/definitions/DeltaHealthEvaluationBool"
        },
        "MonitoringPolicy": {
          "$ref": "#/definitions/MonitoringPolicyDescription"
        },
        "ClusterHealthPolicy": {
          "$ref": "#/definitions/ClusterHealthPolicy"
        },
        "ClusterUpgradeHealthPolicy": {
          "$ref": "#/definitions/ClusterUpgradeHealthPolicyObject"
        },
        "ApplicationHealthPolicyMap": {
          "$ref": "#/definitions/ApplicationHealthPolicyMap"
        }
      }
    },
    "ClusterUpgradeHealthPolicyObject": {
      "type": "object",
      "description": "Defines a health policy used to evaluate the health of the cluster during a cluster upgrade.",
      "properties": {
        "MaxPercentDeltaUnhealthyNodes": {
          "type": "integer",
          "description": "The maximum allowed percentage of nodes health degradation allowed during cluster upgrades. The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. The default value is 10%.",
          "maximum": 100,
          "minimum": 0
        },
        "MaxPercentUpgradeDomainDeltaUnhealthyNodes": {
          "type": "integer",
          "description": "The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades. The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits. The default value is 15%.",
          "maximum": 100,
          "minimum": 0
        }
      }
    },
    "ClusterUpgradeProgressObject": {
      "type": "object",
      "description": "Information about a cluster upgrade.",
      "properties": {
        "CodeVersion": {
          "$ref": "#/definitions/ClusterFabricCodeVersionString"
        },
        "ConfigVersion": {
          "$ref": "#/definitions/ClusterFabricConfigVersionString"
        },
        "UpgradeDomains": {
          "$ref": "#/definitions/UpgradeDomainInfoList"
        },
        "UpgradeState": {
          "$ref": "#/definitions/UpgradeState"
        },
        "NextUpgradeDomain": {
          "$ref": "#/definitions/NextUpgradeDomain"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "UpgradeDescription": {
          "$ref": "#/definitions/ClusterUpgradeDescriptionObject"
        },
        "UpgradeDurationInMilliseconds": {
          "$ref": "#/definitions/UpgradeDurationString"
        },
        "UpgradeDomainDurationInMilliseconds": {
          "$ref": "#/definitions/UpgradeDomainDurationString"
        },
        "UnhealthyEvaluations": {
          "$ref": "#/definitions/UnhealthyEvaluations"
        },
        "CurrentUpgradeDomainProgress": {
          "$ref": "#/definitions/CurrentUpgradeDomainProgressInfo"
        },
        "StartTimestampUtc": {
          "$ref": "#/definitions/UpgradeStartTimeUTCString"
        },
        "FailureTimestampUtc": {
          "$ref": "#/definitions/UpgradeFailureTimeUTCString"
        },
        "FailureReason": {
          "$ref": "#/definitions/FailureReason"
        },
        "UpgradeDomainProgressAtFailure": {
          "$ref": "#/definitions/FailedUpgradeDomainProgressObject"
        }
      }
    },
    "ClusterConfigurationUpgradeDescription": {
      "type": "object",
      "description": "Describes the parameters for a standalone cluster configuration upgrade.",
      "properties": {
        "ClusterConfig": {
          "type": "string",
          "description": "The cluster configuration."
        },
        "HealthCheckRetryTimeout": {
          "type": "string",
          "format": "duration",
          "description": "The length of time between attempts to perform a health checks if the application or cluster is not healthy.",
          "default": "PT0H0M0S"
        },
        "HealthCheckWaitDurationInSeconds": {
          "type": "string",
          "format": "duration",
          "description": "The length of time to wait after completing an upgrade domain before starting the health checks process.",
          "default": "PT0H0M0S"
        },
        "HealthCheckStableDurationInSeconds": {
          "type": "string",
          "format": "duration",
          "description": "The length of time that the application or cluster must remain healthy.",
          "default": "PT0H0M0S"
        },
        "UpgradeDomainTimeoutInSeconds": {
          "type": "string",
          "format": "duration",
          "description": "The timeout for the upgrade domain.",
          "default": "PT0H0M0S"
        },
        "UpgradeTimeoutInSeconds": {
          "type": "string",
          "format": "duration",
          "description": "The upgrade timeout.",
          "default": "PT0H0M0S"
        },
        "MaxPercentUnhealthyApplications": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy applications during the upgrade. Allowed values are integer values from zero to 100.",
          "default": 0
        },
        "MaxPercentUnhealthyNodes": {
          "type": "integer",
          "description": "The maximum allowed percentage of unhealthy nodes during the upgrade. Allowed values are integer values from zero to 100.",
          "default": 0
        },
        "MaxPercentDeltaUnhealthyNodes": {
          "type": "integer",
          "description": "The maximum allowed percentage of delta health degradation during the upgrade. Allowed values are integer values from zero to 100.",
          "default": 0
        },
        "MaxPercentUpgradeDomainDeltaUnhealthyNodes": {
          "type": "integer",
          "description": "The maximum allowed percentage of upgrade domain delta health degradation during the upgrade. Allowed values are integer values from zero to 100.",
          "default": 0
        }
      },
      "required": [
        "ClusterConfig"
      ]
    },
    "DeltaHealthEvaluationBool": {
      "type": "boolean",
      "description": "When true, enables delta health evaluation rather than absolute health evaluation after completion of each upgrade domain."
    },
    "FailedUpgradeDomainProgressObject": {
      "type": "object",
      "description": "The detailed upgrade progress for nodes in the current upgrade domain at the point of failure.",
      "properties": {
        "DomainName": {
          "$ref": "#/definitions/UpgradeDomainName"
        },
        "NodeUpgradeProgressList": {
          "$ref": "#/definitions/NodeUpgradeProgressInfoList"
        }
      }
    },
    "UpgradeDomainDurationString": {
      "type": "string",
      "description": "The estimated elapsed time spent processing the current upgrade domain."
    },
    "UpgradeDurationString": {
      "type": "string",
      "description": "The estimated elapsed time spent processing the current overall upgrade."
    },
    "UpgradeFailureTimeUTCString": {
      "type": "string",
      "description": "The failure time of the upgrade in UTC."
    },
    "UpgradeStartTimeUTCString": {
      "type": "string",
      "description": "The start time of the upgrade in UTC."
    },
    "ApplicationTypeImageStorePath": {
      "description": "Path description for the application package in the image store specified during the prior copy operation.",
      "required": [
        "ApplicationTypeBuildPath"
      ],
      "properties": {
        "ApplicationTypeBuildPath": {
          "type": "string",
          "description": "The relative image store path to the application package."
        }
      }
    },
    "ApplicationTypeImageStoreVersion": {
      "type": "object",
      "description": "A version description for the application type",
      "required": [
        "ApplicationTypeVersion"
      ],
      "properties": {
        "ApplicationTypeVersion": {
          "$ref": "#/definitions/ApplicationTypeVersion"
        }
      }
    },
    "CodePackageName": {
      "type": "string",
      "description": "The name of the code package defined in the service manifest."
    },
    "CodePackageEntryPointStatistics": {
      "type": "object",
      "description": "Statistics about setup or main entry point  of a code package deployed on a Service Fabric node.",
      "properties": {
        "LastExitCode": {
          "type": "string",
          "description": "The last exit code of the entry point."
        },
        "LastActivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The last time (in UTC) when Service Fabric attempted to run the entry point."
        },
        "LastExitTime": {
          "type": "string",
          "format": "date-time",
          "description": "The last time (in UTC) when the entry point finished running."
        },
        "LastSuccessfulActivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The last time (in UTC) when the entry point ran successfully."
        },
        "LastSuccessfulExitTime": {
          "type": "string",
          "format": "date-time",
          "description": "The last time (in UTC) when the entry point finished running gracefully."
        },
        "ActivationCount": {
          "type": "string",
          "description": "Number of times the entry point has run."
        },
        "ActivationFailureCount": {
          "type": "string",
          "description": "Number of times the entry point failed to run."
        },
        "ContinuousActivationFailureCount": {
          "type": "string",
          "description": "Number of times the entry point continuously failed to run."
        },
        "ExitCount": {
          "type": "string",
          "description": "Number of times the entry point finished running."
        },
        "ExitFailureCount": {
          "type": "string",
          "description": "Number of times the entry point failed to exit gracefully."
        },
        "ContinuousExitFailureCount": {
          "type": "string",
          "description": "Number of times the entry point continuously failed to exit gracefully."
        }
      }
    },
    "DeployedCodePackageInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/DeployedCodePackageInfo"
      },
      "description": "List of deployed code package information."
    },
    "DeployedCodePackageInfo": {
      "type": "object",
      "description": "Information about code package deployed on a Service Fabric node.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/CodePackageName"
        },
        "Version": {
          "type": "string",
          "description": "The version of the code package specified in service manifest."
        },
        "ServiceManifestName": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "ServicePackageActivationId": {
          "$ref": "#/definitions/ServicePackageActivationId"
        },
        "HostType": {
          "$ref": "#/definitions/HostType"
        },
        "HostIsolationMode": {
          "$ref": "#/definitions/HostIsolationMode"
        },
        "Status": {
          "$ref": "#/definitions/DeploymentStatus"
        },
        "RunFrequencyInterval": {
          "type": "string",
          "description": "The interval at which code package is run. This is used for periodic code package."
        },
        "SetupEntryPoint": {
          "$ref": "#/definitions/CodePackageEntryPoint"
        },
        "MainEntryPoint": {
          "$ref": "#/definitions/CodePackageEntryPoint"
        }
      }
    },
    "DeploymentStatus": {
      "type": "string",
      "description": "Specifies the status of a deployed application or service package on a Service Fabric node. Possible values are following.\n\n  - Invalid - Indicates status of the application or service package is not known or invalid. The value is 0.\n  - Downloading - Indicates the application or service package is being downloaded to the node from the ImageStore. The value is 1.\n  - Activating - Indicates the application or service package is being activated. The value is 2.\n  - Active - Indicates the application or service package is active the node. The value is 3.\n  - Upgrading - Indicates the application or service package is being upgraded. The value is 4.\n  - Deactivating - Indicates the application or service package is being deactivated. The value is 5.\n",
      "enum": [
        "Invalid",
        "Downloading",
        "Activating",
        "Active",
        "Upgrading",
        "Deactivating"
      ]
    },
    "EntryPointStatus": {
      "type": "string",
      "description": "Specifies the status of the code package entry point deployed on a Service Fabric node. Possible values are following.\n\n  - Invalid - Indicates status of entry point is not known or invalid. The value is 0.\n  - Pending - Indicates the entry point is scheduled to be started. The value is 1.\n  - Starting - Indicates the entry point is being started. The value is 2.\n  - Started - Indicates the entry point was started successfully and is running. The value is 3.\n  - Stopping - Indicates the entry point is being stoppped. The value is 4.\n  - Stopped - Indicates the entry point is not running. The value is 5.\n",
      "enum": [
        "Invalid",
        "Pending",
        "Starting",
        "Started",
        "Stopping",
        "Stopped"
      ]
    },
    "CodePackageEntryPoint": {
      "type": "object",
      "description": "Information about setup or main entry point of a code package deployed on a Service Fabric node.",
      "properties": {
        "EntryPointLocation": {
          "type": "string",
          "description": "The location of entry point executable on the node."
        },
        "ProcessId": {
          "type": "string",
          "description": "The process id of the entry point."
        },
        "RunAsUserName": {
          "type": "string",
          "description": "The user name under which entry point executable is run on the node."
        },
        "CodePackageEntryPointStatistics": {
          "$ref": "#/definitions/CodePackageEntryPointStatistics"
        },
        "Status": {
          "$ref": "#/definitions/EntryPointStatus"
        },
        "NextActivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time (in UTC) when the entry point executable will be run next."
        },
        "InstanceId": {
          "$ref": "#/definitions/CodePackageInstanceId"
        }
      }
    },
    "ChaosContextMapItem": {
      "type": "object",
      "description": "Describes an item in the ChaosContextMap in ChaosParameters.\n",
      "required": [
        "Key",
        "Value"
      ],
      "properties": {
        "Key": {
          "type": "string",
          "description": "The key for a ChaosContextMapItem."
        },
        "Value": {
          "type": "string",
          "description": "The value for a ChaosContextMapItem."
        }
      }
    },
    "ChaosContextMap": {
      "type": "object",
      "description": "Describes a map that contains a collection of ChaosContextMapItem's.\n"
    },
    "ChaosContext": {
      "type": "object",
      "description": "Describes a map, which is a collection of (string, string) type key-value pairs. The map can be used to record information about\nthe Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be at most 4095 characters long.\nThis map is set by the starter of the Chaos run to optionally store the context about the specific run.\n",
      "properties": {
        "Map": {
          "$ref": "#/definitions/ChaosContextMap"
        }
      }
    },
    "ChaosParameters": {
      "type": "object",
      "description": "Defines all the parameters to configure a Chaos run.\n",
      "properties": {
        "TimeToRunInSeconds": {
          "type": "string",
          "description": "Total time (in seconds) for which Chaos will run before automatically stopping. The maximum allowed value is 4,294,967,295 (System.UInt32.MaxValue).\n",
          "default": "4294967295"
        },
        "MaxClusterStabilizationTimeoutInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum amount of time to wait for all cluster entities to become stable and healthy. Chaos executes in iterations and at the start of each iteration it validates the health of cluster entities.\nDuring validation if a cluster entity is not stable and healthy within MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed event.\n",
          "default": 60,
          "minimum": 0,
          "maximum": 4294967295
        },
        "MaxConcurrentFaults": {
          "type": "integer",
          "format": "int64",
          "description": "MaxConcurrentFaults is the maximum number of concurrent faults induced per iteration.\nChaos executes in iterations and two consecutive iterations are separated by a validation phase.\nThe higher the concurrency, the more aggressive the injection of faults -- inducing more complex series of states to uncover bugs.\nThe recommendation is to start with a value of 2 or 3 and to exercise caution while moving up.\n",
          "default": 1,
          "minimum": 0,
          "maximum": 4294967295
        },
        "EnableMoveReplicaFaults": {
          "type": "boolean",
          "description": "Enables or disables the move primary and move secondary faults.\n",
          "default": true
        },
        "WaitTimeBetweenFaultsInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "Wait time (in seconds) between consecutive faults within a single iteration.\nThe larger the value, the lower the overlapping between faults and the simpler the sequence of state transitions that the cluster goes through.\nThe recommendation is to start with a value between 1 and 5 and exercise caution while moving up.\n",
          "default": 20,
          "minimum": 0,
          "maximum": 4294967295
        },
        "WaitTimeBetweenIterationsInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "Time-separation (in seconds) between two consecutive iterations of Chaos.\nThe larger the value, the lower the fault injection rate.\n",
          "default": 30,
          "minimum": 0,
          "maximum": 4294967295
        },
        "ClusterHealthPolicy": {
          "$ref": "#/definitions/ClusterHealthPolicy"
        },
        "Context": {
          "$ref": "#/definitions/ChaosContext"
        }
      }
    },
    "ChaosEvent": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Represents an event generated during a Chaos run.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/ChaosEventKind"
        },
        "TimeStampUtc": {
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "Kind",
        "TimeStampUtc"
      ]
    },
    "ChaosEventWrapper": {
      "type": "object",
      "description": "Wrapper object for Chaos event.",
      "properties": {
        "ChaosEvent": {
          "$ref": "#/definitions/ChaosEvent"
        }
      }
    },
    "ChaosEventKind": {
      "type": "string",
      "description": "The kind of Chaos event.\n\n- Invalid - Indicates an invalid Chaos event kind. All Service Fabric enumerations have the invalid type.\nThe valus is zero.\n- Started - Indicates a Chaos event that gets generated when Chaos is started.\n- ExecutingFaults - Indicates a Chaos event that gets generated when Chaos has decided on the faults for an iteration. This Chaos event contains the details of the faults as a list of strings.\n- Waiting - Indicatges a Chaos event that gets generated when Chaos is waiting for the cluster to become ready for faulting, for example, Chaos may be waiting for the on-going upgrade to finish.\n- ValidationFailed - Indicates a Chaos event that gets generated when the cluster entities do not become stable and healthy within ChaosParameters.MaxClusterStabilizationTimeoutInSeconds.\n- TestError - Indicates a Chaos event that gets generated when an unexpected event has occurred in the Chaos engine, for example, due to the cluster snapshot being inconsistent, while faulting a faultable entity Chaos found that the entity was alreay faulted.\n- Stopped - Indicates a Chaos event that gets generated when Chaos stops because either the user issued a stop or the time to run was up.\n",
      "enum": [
        "Invalid",
        "Started",
        "ExecutingFaults",
        "Waiting",
        "ValidationFailed",
        "TestError",
        "Stopped"
      ]
    },
    "ChaosReport": {
      "type": "object",
      "description": "Contains detailed Chaos report.\n",
      "properties": {
        "ChaosParameters": {
          "$ref": "#/definitions/ChaosParameters"
        },
        "Status": {
          "type": "string",
          "description": "Current status of the Chaos run.\n\n- Invalid - Indicates an invalid Chaos status. All Service Fabric enumerations have the invalid type.\n  The valus is zero.\n- Running - Indicates that Chaos is not stopped.\n- Stopped - Indicates that Chaos is not scheduling futher faults.",
          "enum": [
            "Invalid",
            "Running",
            "Stopped"
          ]
        },
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "History": {
          "$ref": "#/definitions/ChaosEventHistory"
        }
      }
    },
    "ExecutingFaultsChaosEvent": {
      "description": "Describes a Chaos event that gets generated when Chaos has decided on the faults for an iteration. This Chaos event contains the details of the faults as a list of strings.",
      "x-ms-discriminator-value": "ExecutingFaults",
      "allOf": [
        {
          "$ref": "#/definitions/ChaosEvent"
        },
        {
          "type": "object",
          "description": "ExecutingFaultsChaosEvent",
          "properties": {
            "Faults": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      ]
    },
    "StartedChaosEvent": {
      "description": "Describes a Chaos event that gets generated when Chaos is started.",
      "x-ms-discriminator-value": "Started",
      "allOf": [
        {
          "$ref": "#/definitions/ChaosEvent"
        },
        {
          "type": "object",
          "description": "StartedChaosEvent",
          "properties": {
            "ChaosParameters": {
              "$ref": "#/definitions/ChaosParameters"
            }
          }
        }
      ]
    },
    "StoppedChaosEvent": {
      "description": "Describes a Chaos event that gets generated when Chaos stops because either the user issued a stop or the time to run was up.",
      "x-ms-discriminator-value": "Stopped",
      "allOf": [
        {
          "$ref": "#/definitions/ChaosEvent"
        },
        {
          "type": "object",
          "description": "StoppedChaosEvent",
          "properties": {
            "Reason": {
              "type": "string"
            }
          }
        }
      ]
    },
    "TestErrorChaosEvent": {
      "description": "Describes a Chaos event that gets generated when an unexpected event occurs in the Chaos engine.\nFor example, due to the cluster snapshot being inconsistent, while faulting a faultable entity, Chaos found that the entity was alreay faulted -- which would be an unexpected event.\n",
      "x-ms-discriminator-value": "TestError",
      "allOf": [
        {
          "$ref": "#/definitions/ChaosEvent"
        },
        {
          "type": "object",
          "description": "TestErrorChaosEvent",
          "properties": {
            "Reason": {
              "type": "string"
            }
          }
        }
      ]
    },
    "ValidationFailedChaosEvent": {
      "description": "Chaos event corresponding to a failure during validation.",
      "x-ms-discriminator-value": "ValidationFailed",
      "allOf": [
        {
          "$ref": "#/definitions/ChaosEvent"
        },
        {
          "type": "object",
          "description": "ValidationFailedChaosEvent",
          "properties": {
            "Reason": {
              "type": "string"
            }
          }
        }
      ]
    },
    "WaitingChaosEvent": {
      "description": "Describes a Chaos event that gets generated when Chaos is waiting for the cluster to become ready for faulting, for example, Chaos may be waiting for the on-going upgrade to finish.",
      "x-ms-discriminator-value": "Waiting",
      "allOf": [
        {
          "$ref": "#/definitions/ChaosEvent"
        },
        {
          "type": "object",
          "description": "WaitingChaosEvent",
          "properties": {
            "Reason": {
              "type": "string"
            }
          }
        }
      ]
    },
    "ChaosEventHistory": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ChaosEventWrapper"
      }
    },
    "ApplicationTypeVersion": {
      "type": "string",
      "description": "The version of the application type as defined in the application manifest."
    },
    "ApplicationCapacityDescription": {
      "type": "object",
      "description": "Describes capacity information for services of this application. This description can be used for describing the following.\n- Reserving the capacity for the services on the nodes\n- Limiting the total number of nodes that services of this application can run on\n- Limiting the custom capacity metrics to limit the total consumption of this metric by the services of this application\n",
      "properties": {
        "MinimumNodes": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. If this property is set to zero, no capacity will be reserved. The value of this property cannot be more than the value of the MaximumNodes property.",
          "minimum": 0
        },
        "MaximumNodes": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. By default, the value of this property is zero and it means that the services can be placed on any node.",
          "minimum": 0,
          "default": 0
        },
        "ApplicationMetrics": {
          "$ref": "#/definitions/ApplicationMetricDescriptionList"
        }
      }
    },
    "ApplicationDescription": {
      "type": "object",
      "description": "Describes a Service Fabric application.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/ApplicationName"
        },
        "TypeName": {
          "$ref": "#/definitions/ApplicationTypeName"
        },
        "TypeVersion": {
          "$ref": "#/definitions/ApplicationTypeVersion"
        },
        "ParameterList": {
          "$ref": "#/definitions/ApplicationParameterList"
        },
        "ApplicationCapacity": {
          "$ref": "#/definitions/ApplicationCapacityDescription"
        }
      },
      "required": [
        "Name",
        "TypeName",
        "TypeVersion"
      ]
    },
    "ApplicationMetricDescription": {
      "type": "object",
      "description": "Describes capacity information for a custom resource balancing metric. This can be used to limit the total consumption of this metric by the services of this application.\n",
      "properties": {
        "Name": {
          "type": "string",
          "description": "The name of the metric."
        },
        "MaximumCapacity": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum node capacity for Service Fabric application.\nThis is the maximum Load for an instance of this application on a single node. Even if the capacity of node is greater than this value, Service Fabric will limit the total load of services within the application on each node to this value.\nIf set to zero, capacity for this metric is unlimited on each node.\nWhen creating a new application with application capacity defined, the product of MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.\nWhen updating existing application with application capacity, the product of MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.\n"
        },
        "ReservationCapacity": {
          "type": "integer",
          "format": "int64",
          "description": "The node reservation capacity for Service Fabric application.\nThis is the amount of load which is reserved on nodes which have instances of this application.\nIf MinimumNodes is specified, then the product of these values will be the capacity reserved in the cluster for the application.\nIf set to zero, no capacity is reserved for this metric.\nWhen setting application capacity or when updating application capacity; this value must be smaller than or equal to MaximumCapacity for each metric.\n"
        },
        "TotalApplicationCapacity": {
          "description": "The total metric capacity for Service Fabric application.\nThis is the total metric capacity for this application in the cluster. Service Fabric will try to limit the sum of loads of services within the application to this value.\nWhen creating a new application with application capacity defined, the product of MaximumNodes and MaximumCapacity must always be smaller than or equal to this value.\n",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "ApplicationMetricDescriptionList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ApplicationMetricDescription"
      },
      "description": "List of application capacity metric description."
    },
    "ComposeDeploymentStatus": {
      "type": "string",
      "description": "The status of the compose deployment. Possible values are.\n\n- Invalid - Indicates that the compose deployment status is invalid. The value is zero.\n- Provisioning - Indicates that the compose deployment is being provisioned in background. The value is 1.\n- Creating - Indicates that the compose deployment is being created in background. The value is 2.\n- Ready - Indicates that the compose deployment has been successfully created or upgraded. The value is 3.\n- Unprovisioning - Indicates that the compose deployment is being unprovisioned in background. The value is 4.\n- Deleting - Indicates that the compose deployment is being deleted in background. The value is 5.\n- Failed - Indicates that the compose deployment was terminated due to persistent failures. The value is 6.\n- Upgrading - Indicates that the compose deployment is being upgraded in the background. The value is 7.\n",
      "enum": [
        "Invalid",
        "Provisioning",
        "Creating",
        "Ready",
        "Unprovisioning",
        "Deleting",
        "Failed",
        "Upgrading"
      ]
    },
    "ComposeDeploymentStatusInfo": {
      "type": "object",
      "description": "Information about a Service Fabric compose deployment.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/DeploymentName"
        },
        "ApplicationName": {
          "$ref": "#/definitions/ApplicationName"
        },
        "Status": {
          "$ref": "#/definitions/ComposeDeploymentStatus"
        },
        "StatusDetails": {
          "description": "The status details of compose deployment including failure message.",
          "type": "string"
        }
      }
    },
    "ComposeDeploymentUpgradeDescription": {
      "type": "object",
      "description": "Describes the parameters for a compose deployment upgrade.",
      "properties": {
        "DeploymentName": {
          "$ref": "#/definitions/DeploymentName"
        },
        "ComposeFileContent": {
          "type": "string",
          "description": "The content of the compose file that describes the deployment to create."
        },
        "RegistryCredential": {
          "$ref": "#/definitions/RegistryCredential"
        },
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeKind"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "UpgradeReplicaSetCheckTimeoutInSeconds": {
          "$ref": "#/definitions/UpgradeReplicaSetCheckTimeout"
        },
        "ForceRestart": {
          "$ref": "#/definitions/ForceRestart"
        },
        "MonitoringPolicy": {
          "$ref": "#/definitions/MonitoringPolicyDescription"
        },
        "ApplicationHealthPolicy": {
          "$ref": "#/definitions/ApplicationHealthPolicy"
        }
      },
      "required": [
        "DeploymentName",
        "ComposeFileContent",
        "UpgradeKind"
      ]
    },
    "ComposeDeploymentUpgradeProgressInfo": {
      "type": "object",
      "description": "Describes the parameters for a compose deployment upgrade.",
      "properties": {
        "DeploymentName": {
          "$ref": "#/definitions/TargetDeploymentName"
        },
        "ApplicationName": {
          "$ref": "#/definitions/TargetApplicationName"
        },
        "UpgradeState": {
          "$ref": "#/definitions/ComposeDeploymentUpgradeState"
        },
        "UpgradeStatusDetails": {
          "type": "string"
        },
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeKind"
        },
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "ForceRestart": {
          "$ref": "#/definitions/ForceRestart"
        },
        "UpgradeReplicaSetCheckTimeoutInSeconds": {
          "$ref": "#/definitions/UpgradeReplicaSetCheckTimeout"
        },
        "MonitoringPolicy": {
          "$ref": "#/definitions/MonitoringPolicyDescription"
        },
        "ApplicationHealthPolicy": {
          "$ref": "#/definitions/ApplicationHealthPolicy"
        },
        "TargetApplicationTypeVersion": {
          "$ref": "#/definitions/TargetApplicationTypeVersion"
        },
        "UpgradeDuration": {
          "$ref": "#/definitions/UpgradeDuration"
        },
        "CurrentUpgradeDomainDuration": {
          "$ref": "#/definitions/CurrentUpgradeDomainDuration"
        },
        "ApplicationUnhealthyEvaluations": {
          "$ref": "#/definitions/ApplicationUnhealthyEvaluations"
        },
        "CurrentUpgradeDomainProgress": {
          "$ref": "#/definitions/CurrentUpgradeDomainProgressInfo"
        },
        "StartTimestampUtc": {
          "type": "string"
        },
        "FailureTimestampUtc": {
          "type": "string"
        },
        "FailureReason": {
          "$ref": "#/definitions/FailureReason"
        },
        "UpgradeDomainProgressAtFailure": {
          "$ref": "#/definitions/FailureUpgradeDomainProgressInfo"
        },
        "ApplicationUpgradeStatusDetails": {
          "type": "string"
        }
      }
    },
    "ComposeDeploymentUpgradeState": {
      "type": "string",
      "description": "The state of the compose deployment upgrade.\n\n    - Invalid - Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n    - ProvisioningTarget - The upgrade is in the progress of provisioning target application type version. The value is 1.\n    - RollingForwardInProgress - The upgrade is rolling forward to the target version but is not complete yet. The value is 2.\n    - RollingForwardPending - The current upgrade domain has finished upgrading. The overall upgrade is waiting for an explicit move next request in UnmonitoredManual mode or performing health checks in Monitored mode. The value is 3\n    - UnprovisioningCurrent - The upgrade is in the progress of unprovisioning current application type version and rolling forward to the target version is completed. The value is 4.\n    - RollingForwardCompleted - The upgrade has finished rolling forward. The value is 5.\n    - RollingBackInProgress - The upgrade is rolling back to the previous version but is not complete yet. The value is 6.\n    - UnprovisioningTarget - The upgrade is in the progress of unprovisioning target application type version and rolling back to the current version is completed. The value is 7.\n    - RollingBackCompleted - The upgrade has finished rolling back. The valud is 8.\n    - Failed - The upgrade has failed and is unable to execute FailureAction. The value is 9.\n",
      "enum": [
        "Invalid",
        "ProvisioningTarget",
        "RollingForwardInProgress",
        "RollingForwardPending",
        "UnprovisioningCurrent",
        "RollingForwardCompleted",
        "RollingBackInProgress",
        "UnprovisioningTarget",
        "RollingBackCompleted",
        "Failed"
      ]
    },
    "PagedComposeDeploymentStatusInfoList": {
      "type": "object",
      "description": "The list of compose deployments in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "Items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ComposeDeploymentStatusInfo"
          }
        }
      }
    },
    "CreateComposeDeploymentDescription": {
      "type": "object",
      "description": "Defines description for creating a Service Fabric compose deployment.\n",
      "properties": {
        "DeploymentName": {
          "$ref": "#/definitions/DeploymentName"
        },
        "ComposeFileContent": {
          "type": "string",
          "description": "The content of the compose file that describes the deployment to create."
        },
        "RegistryCredential": {
          "$ref": "#/definitions/RegistryCredential"
        }
      },
      "required": [
        "DeploymentName",
        "ComposeFileContent"
      ]
    },
    "RegistryCredential": {
      "type": "object",
      "description": "Credential information to connect to container registry.",
      "properties": {
        "RegistryUserName": {
          "type": "string",
          "description": "The user name to connect to container registry."
        },
        "RegistryPassword": {
          "type": "string",
          "description": "The password for supplied username to connect to container registry."
        },
        "PasswordEncrypted": {
          "type": "boolean",
          "description": "Indicates that supplied container registry password is encrypted."
        }
      }
    },
    "DeployedServicePackageInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/DeployedServicePackageInfo"
      },
      "description": "List of deployed service package information."
    },
    "DeployedServicePackageInfo": {
      "type": "object",
      "description": "Information about service package deployed on a Service Fabric node.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "Version": {
          "type": "string",
          "description": "The version of the service package specified in service manifest."
        },
        "Status": {
          "$ref": "#/definitions/DeploymentStatus"
        },
        "ServicePackageActivationId": {
          "$ref": "#/definitions/ServicePackageActivationId"
        }
      }
    },
    "DeploymentName": {
      "type": "string",
      "description": "The name of the deployment."
    },
    "CorrelationSchemeList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServiceCorrelationDescription"
      },
      "description": "A list that describes the correlation of the service with other services."
    },
    "MoveCost": {
      "type": "string",
      "description": "Specifies the move cost for the service. Possible values are the following.\n\n  - Zero - Zero move cost. This value is zero.\n  - Low - Specifies the move cost of the service as Low. The value is 1.\n  - Medium - Specifies the move cost of the service as Medium. The value is 2.\n  - High - Specifies the move cost of the service as High. The value is 3.\n",
      "enum": [
        "Zero",
        "Low",
        "Medium",
        "High"
      ]
    },
    "PartitionScheme": {
      "type": "string",
      "description": "Enumerates the ways that a service can be partitioned. Possible values are:\n\n- Invalid - Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n- Singleton - Indicates that the partition is based on string names, and is a SingletonPartitionSchemeDescription object, The value is 1.\n- UniformInt64Range - Indicates that the partition is based on Int64 key ranges, and is a UniformInt64RangePartitionSchemeDescription object. The value is 2.\n- Named - Indicates that the partition is based on string names, and is a NamedPartitionSchemeDescription object. The value is 3\n",
      "enum": [
        "Invalid",
        "Singleton",
        "UniformInt64Range",
        "Named"
      ]
    },
    "ServiceCorrelationDescription": {
      "type": "object",
      "description": "Creates a particular correlation between services.",
      "required": [
        "Scheme",
        "ServiceName"
      ],
      "properties": {
        "Scheme": {
          "$ref": "#/definitions/ServiceCorrelationScheme"
        },
        "ServiceName": {
          "$ref": "#/definitions/ServiceName"
        }
      }
    },
    "ServiceCorrelationScheme": {
      "type": "string",
      "description": "The service correlation scheme. Possible values are following.\n\n  - Invalid - An invalid correlation scheme. Cannot be used. The value is zero.\n  - Affinity - Indicates that this service has an affinity relationship with another service. Provided for backwards compatibility, consider preferring the Aligned or NonAlignedAffinity options. The value is 1.\n  - AlignedAffinity - Aligned affinity ensures that the primaries of the partitions of the affinitized services are collocated on the same nodes. This is the default and is the same as selecting the Affinity scheme. The value is 2.\n  - NonAlignedAffinity - Non-Aligned affinity guarantees that all replicas of each service will be placed on the same nodes. Unlike Aligned Affinity, this does not guarantee that replicas of particular role will be collocated. The value is 3.\n",
      "enum": [
        "Invalid",
        "Affinity",
        "AlignedAffinity",
        "NonAlignedAffinity"
      ]
    },
    "ServiceLoadMetricsList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServiceLoadMetricDescription"
      },
      "description": "The service load metrics is given as an array of ServiceLoadMetricDescription objects."
    },
    "ServiceLoadMetricDescription": {
      "type": "object",
      "description": "Specifies a metric to load balance a service during runtime.",
      "required": [
        "Name"
      ],
      "properties": {
        "Name": {
          "type": "string",
          "description": "The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive."
        },
        "Weight": {
          "$ref": "#/definitions/ServiceLoadMetricWeight"
        },
        "PrimaryDefaultLoad": {
          "type": "integer",
          "description": "Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica."
        },
        "SecondaryDefaultLoad": {
          "type": "integer",
          "description": "Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica."
        },
        "DefaultLoad": {
          "type": "integer",
          "description": "Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric."
        }
      }
    },
    "ServiceLoadMetricWeight": {
      "type": "string",
      "description": "Determines the metric weight relative to the other metrics that are configured for this service. During runtime, if two metrics end up in conflict, the Cluster Resource Manager prefers the metric with the higher weight. Possible values are following.\n\n  - Zero - Disables resource balancing for this metric. This value is zero.\n  - Low - Specifies the metric weight of the service load as Low. The value is 1.\n  - Medium - Specifies the metric weight of the service load as Medium. The value is 2.\n  - High - Specifies the metric weight of the service load as High. The value is 3.\n",
      "enum": [
        "Zero",
        "Low",
        "Medium",
        "High"
      ]
    },
    "ServicePackageActivationMode": {
      "type": "string",
      "description": "The activation mode of service package to be used for a Service Fabric service. This is specified at the time of creating the Service. Possible values are following.\n\n  - SharedProcess - This is the default activation mode. With this activation mode, replicas or instances from different partition(s) of service, on a given node, will share same activation of service package on a node. The value is zero.\n  - ExclusiveProcess - With this activation mode, each replica or instance of service, on a given node, will have its own dedicated activation of service package on a node. The value is 1.\n",
      "enum": [
        "SharedProcess",
        "ExclusiveProcess"
      ]
    },
    "ServicePlacementPoliciesList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ServicePlacementPolicyDescription"
      },
      "description": "A list that describes the correlation of the service with other services."
    },
    "PartitionSchemeDescription": {
      "type": "object",
      "discriminator": "PartitionScheme",
      "description": "Describes how the service is partitioned.",
      "required": [
        "PartitionScheme"
      ],
      "properties": {
        "PartitionScheme": {
          "$ref": "#/definitions/PartitionScheme"
        }
      }
    },
    "NamedPartitionSchemeDescription": {
      "description": "Describes the named partition scheme of the service.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSchemeDescription"
        },
        {
          "type": "object",
          "description": "NamedPartitionSchemeDescription"
        }
      ],
      "x-ms-discriminator-value": "Named",
      "required": [
        "Count",
        "Names"
      ],
      "properties": {
        "Count": {
          "type": "integer",
          "description": "The number of partitions."
        },
        "Names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Array of size specified by the Count parameter, for the names of the partitions."
        }
      }
    },
    "SingletonPartitionSchemeDescription": {
      "description": "Describes the partition scheme of a singleton-partitioned, or non-partitioned service.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSchemeDescription"
        },
        {
          "type": "object",
          "description": "SingletonPartitionSchemeDescription"
        }
      ],
      "x-ms-discriminator-value": "Singleton"
    },
    "UniformInt64RangePartitionSchemeDescription": {
      "description": "Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.",
      "allOf": [
        {
          "$ref": "#/definitions/PartitionSchemeDescription"
        },
        {
          "type": "object",
          "description": "UniformInt64RangePartitionSchemeDescription"
        }
      ],
      "x-ms-discriminator-value": "UniformInt64Range",
      "required": [
        "Count",
        "LowKey",
        "HighKey"
      ],
      "properties": {
        "Count": {
          "type": "integer",
          "description": "The number of partitions."
        },
        "LowKey": {
          "type": "string",
          "description": "String indicating the lower bound of the partition key range that\nshould be split between the partition Count\n"
        },
        "HighKey": {
          "type": "string",
          "description": "String indicating the upper bound of the partition key range that\nshould be split between the partition Count\n"
        }
      }
    },
    "ServiceDescription": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "A ServiceDescription contains all of the information necessary to create a service.",
      "required": [
        "ServiceKind",
        "ServiceName",
        "ServiceTypeName",
        "PartitionDescription"
      ],
      "properties": {
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "ApplicationName": {
          "$ref": "#/definitions/ApplicationName"
        },
        "ServiceName": {
          "$ref": "#/definitions/ServiceName"
        },
        "ServiceTypeName": {
          "$ref": "#/definitions/ServiceTypeName"
        },
        "InitializationData": {
          "$ref": "#/definitions/ByteArray"
        },
        "PartitionDescription": {
          "$ref": "#/definitions/PartitionSchemeDescription"
        },
        "PlacementConstraints": {
          "type": "string",
          "description": "The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: \"NodeColor == blue)\"."
        },
        "CorrelationScheme": {
          "$ref": "#/definitions/CorrelationSchemeList"
        },
        "ServiceLoadMetrics": {
          "$ref": "#/definitions/ServiceLoadMetricsList"
        },
        "ServicePlacementPolicies": {
          "$ref": "#/definitions/ServicePlacementPoliciesList"
        },
        "DefaultMoveCost": {
          "$ref": "#/definitions/MoveCost"
        },
        "IsDefaultMoveCostSpecified": {
          "type": "boolean",
          "description": "Indicates if the DefaultMoveCost property is specified."
        },
        "ServicePackageActivationMode": {
          "$ref": "#/definitions/ServicePackageActivationMode"
        },
        "ServiceDnsName": {
          "type": "string",
          "description": "The DNS name of the service. It requires the DNS system service to be enabled in Service Fabric cluster."
        }
      }
    },
    "StatefulServiceDescription": {
      "description": "Describes a stateful service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceDescription"
        },
        {
          "type": "object",
          "description": "StatefulServiceDescription"
        }
      ],
      "x-ms-discriminator-value": "Stateful",
      "required": [
        "TargetReplicaSetSize",
        "MinReplicaSetSize",
        "HasPersistedState"
      ],
      "properties": {
        "TargetReplicaSetSize": {
          "type": "integer",
          "minimum": 1,
          "description": "The target replica set size as a number."
        },
        "MinReplicaSetSize": {
          "type": "integer",
          "minimum": 1,
          "description": "The minimum replica set size as a number."
        },
        "HasPersistedState": {
          "type": "boolean",
          "description": "A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false."
        },
        "Flags": {
          "type": "integer",
          "description": "Flags indicating whether other properties are set. Each of the associated properties corresponds to a flag, specified below, which, if set, indicate that the property is specified.\nThis property can be a combination of those flags obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then the flags for QuorumLossWaitDuration (2) and StandByReplicaKeepDuration(4) are set.\n\n- None - Does not indicate any other properties are set. The value is zero.\n- ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The value is 1.\n- QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is 2.\n- StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The value is 4.\n"
        },
        "ReplicaRestartWaitDurationSeconds": {
          "type": "integer",
          "format": "int64",
          "minimum": 0,
          "maximum": 4294967295,
          "description": "The duration, in seconds, between when a replica goes down and when a new replica is created."
        },
        "QuorumLossWaitDurationSeconds": {
          "type": "integer",
          "format": "int64",
          "minimum": 0,
          "maximum": 4294967295,
          "description": "The maximum duration, in seconds, for which a partition is allowed to be in a state of quorum loss."
        },
        "StandByReplicaKeepDurationSeconds": {
          "type": "integer",
          "format": "int64",
          "minimum": 0,
          "maximum": 4294967295,
          "description": "The definition on how long StandBy replicas should be maintained before being removed."
        }
      }
    },
    "StatelessServiceDescription": {
      "description": "Describes a stateless service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceDescription"
        },
        {
          "type": "object",
          "description": "StatelessServiceDescription"
        }
      ],
      "x-ms-discriminator-value": "Stateless",
      "required": [
        "InstanceCount"
      ],
      "properties": {
        "InstanceCount": {
          "type": "integer",
          "minimum": -1,
          "description": "The instance count."
        }
      }
    },
    "ReplicatorQueueStatus": {
      "type": "object",
      "description": "Provides various statistics of the queue used in the service fabric replicator.\nContains information about the service fabric replicator like the replication/copy queue utilization, last acknowledgement received timestamp, etc.\nDepending on the role of the replicator, the properties in this type imply different meanings.\n",
      "properties": {
        "QueueUtilizationPercentage": {
          "type": "integer",
          "format": "int32",
          "description": "Represents the utilization of the queue. A value of 0 indicates that the queue is empty and a value of 100 indicates the queue is full."
        },
        "QueueMemorySize": {
          "type": "string",
          "description": "Represents the virtual memory consumed by the queue in bytes."
        },
        "FirstSequenceNumber": {
          "type": "string",
          "description": "On a primary replicator, this is semantically the sequence number of the operation for which all the secondary replicas have sent an acknowledgement.\nOn a secondary replicator, this is the smallest sequence number of the operation that is present in the queue.\n"
        },
        "CompletedSequenceNumber": {
          "type": "string",
          "description": "On a primary replicator, this is semantically the highest sequence number of the operation for which all the secondary replicas have sent an acknowledgement.\nOn a secondary replicator, this is semantically the highest sequence number that has been applied to the persistent state.\n"
        },
        "CommittedSequenceNumber": {
          "type": "string",
          "description": "On a primary replicator, this is semantically the highest sequence number of the operation for which a write quorum of the secondary replicas have sent an acknowledgement.\nOn a secondary replicator, this is semantically the highest sequence number of the in-order operation received from the primary.\n"
        },
        "LastSequenceNumber": {
          "type": "string",
          "description": "Represents the latest sequence number of the operation that is available in the queue."
        }
      }
    },
    "ReplicatorStatus": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Represents a base class for primary or secondary replicator status.\nContains information about the service fabric replicator like the replication/copy queue utilization, last acknowledgement received timestamp, etc.\n",
      "required": [
        "Kind"
      ],
      "properties": {
        "Kind": {
          "$ref": "#/definitions/ReplicaRole"
        }
      }
    },
    "PrimaryReplicatorStatus": {
      "x-ms-discriminator-value": "Primary",
      "type": "object",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicatorStatus"
        },
        {
          "type": "object",
          "description": "Status of the primary replicator.",
          "properties": {
            "ReplicationQueueStatus": {
              "$ref": "#/definitions/ReplicatorQueueStatus"
            },
            "RemoteReplicators": {
              "$ref": "#/definitions/RemoteReplicatorStatusList"
            }
          }
        }
      ]
    },
    "SecondaryReplicatorStatus": {
      "type": "object",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicatorStatus"
        },
        {
          "type": "object",
          "description": "Represents a base class for secondary replicator status.\n",
          "properties": {
            "ReplicationQueueStatus": {
              "$ref": "#/definitions/ReplicatorQueueStatus"
            },
            "LastReplicationOperationReceivedTimeUtc": {
              "type": "string",
              "format": "date-time",
              "description": "The last time-stamp (UTC) at which a replication operation was received from the primary.\nUTC 0 represents an invalid value, indicating that a replication operation message was never received.\n"
            },
            "IsInBuild": {
              "type": "boolean",
              "description": "Value that indicates whether the replica is currently being built."
            },
            "CopyQueueStatus": {
              "$ref": "#/definitions/ReplicatorQueueStatus"
            },
            "LastCopyOperationReceivedTimeUtc": {
              "type": "string",
              "format": "date-time",
              "description": "The last time-stamp (UTC) at which a copy operation was received from the primary.\nUTC 0 represents an invalid value, indicating that a copy operation message was never received.\n"
            },
            "LastAcknowledgementSentTimeUtc": {
              "type": "string",
              "format": "date-time",
              "description": "The last time-stamp (UTC) at which an acknowledgment was sent to the primary replicator.\nUTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.\n"
            }
          }
        }
      ]
    },
    "SecondaryActiveReplicatorStatus": {
      "x-ms-discriminator-value": "ActiveSecondary",
      "description": "Status of the secondary replicator when it is in active mode and is part of the replica set.",
      "allOf": [
        {
          "$ref": "#/definitions/SecondaryReplicatorStatus"
        },
        {
          "type": "object"
        }
      ]
    },
    "SecondaryIdleReplicatorStatus": {
      "x-ms-discriminator-value": "IdleSecondary",
      "description": "Status of the secondary replicator when it is in idle mode and is being built by the primary.",
      "allOf": [
        {
          "$ref": "#/definitions/SecondaryReplicatorStatus"
        },
        {
          "type": "object"
        }
      ]
    },
    "RemoteReplicatorStatus": {
      "type": "object",
      "description": "Represents the state of the secondary replicator from the primary replicators point of view.\n",
      "properties": {
        "ReplicaId": {
          "$ref": "#/definitions/ReplicaId"
        },
        "LastAcknowledgementProcessedTimeUtc": {
          "type": "string",
          "format": "date-time",
          "description": "The last timestamp (in UTC) when an acknowledgement from the secondary replicator was processed on the primary.\nUTC 0 represents an invalid value, indicating that no acknowledgement messages were ever processed.\n"
        },
        "LastReceivedReplicationSequenceNumber": {
          "type": "string",
          "description": "The highest replication operation sequence number that the secondary has received from the primary."
        },
        "LastAppliedReplicationSequenceNumber": {
          "type": "string",
          "description": "The highest replication operation sequence number that the secondary has applied to its state."
        },
        "IsInBuild": {
          "type": "boolean",
          "description": "A value that indicates whether the secondary replica is in the process of being built."
        },
        "LastReceivedCopySequenceNumber": {
          "type": "string",
          "description": "The highest copy operation sequence number that the secondary has received from the primary.\nA value of -1 implies that the secondary has received all copy operations.\n"
        },
        "LastAppliedCopySequenceNumber": {
          "type": "string",
          "description": "The highest copy operation sequence number that the secondary has applied to its state.\nA value of -1 implies that the secondary has applied all copy operations and the copy process is complete.\n"
        },
        "RemoteReplicatorAcknowledgementStatus": {
          "$ref": "#/definitions/RemoteReplicatorAcknowledgementStatus"
        }
      }
    },
    "RemoteReplicatorStatusList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/RemoteReplicatorStatus"
      },
      "description": "List of remote replicator status"
    },
    "RemoteReplicatorAcknowledgementStatus": {
      "type": "object",
      "description": "Provides details about the remote replicators from the primary replicator's point of view.",
      "properties": {
        "ReplicationStreamAcknowledgementDetail": {
          "$ref": "#/definitions/RemoteReplicatorAcknowledgementDetail"
        },
        "CopyStreamAcknowledgementDetail": {
          "$ref": "#/definitions/RemoteReplicatorAcknowledgementDetail"
        }
      }
    },
    "RemoteReplicatorAcknowledgementDetail": {
      "type": "object",
      "description": "Provides various statistics of the acknowledgements that are being received from the remote replicator.",
      "properties": {
        "AverageReceiveDuration": {
          "type": "string",
          "description": "Represents the average duration it takes for the remote replicator to receive an operation."
        },
        "AverageApplyDuration": {
          "type": "string",
          "description": "Represents the average duration it takes for the remote replicator to apply an operation. This usually entails writing the operation to disk."
        },
        "NotReceivedCount": {
          "type": "string",
          "description": "Represents the number of operations not yet received by a remote replicator."
        },
        "ReceivedAndNotAppliedCount": {
          "type": "string",
          "description": "Represents the number of operations received and not yet applied by a remote replicator."
        }
      }
    },
    "DeployedServiceReplicaDetailInfo": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "Information about a Service Fabric service replica deployed on a node.",
      "required": [
        "ServiceKind"
      ],
      "properties": {
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "ServiceName": {
          "$ref": "#/definitions/ServiceName"
        },
        "PartitionId": {
          "$ref": "#/definitions/PartitionId"
        },
        "CurrentServiceOperation": {
          "$ref": "#/definitions/ServiceOperationName"
        },
        "CurrentServiceOperationStartTimeUtc": {
          "type": "string",
          "format": "date-time",
          "description": "The start time of the current service operation in UTC format."
        },
        "ReportedLoad": {
          "$ref": "#/definitions/LoadMetricReportInfoList"
        }
      }
    },
    "DeployedStatefulServiceReplicaDetailInfo": {
      "description": "Information about a stateful replica running in a code package. Please note DeployedServiceReplicaQueryResult will contain duplicate data like ServiceKind, ServiceName, PartitionId and replicaId.",
      "x-ms-discriminator-value": "Stateful",
      "allOf": [
        {
          "$ref": "#/definitions/DeployedServiceReplicaDetailInfo"
        },
        {
          "type": "object",
          "description": "DeployedStatefulServiceReplicaDetailInfo",
          "properties": {
            "ReplicaId": {
              "$ref": "#/definitions/ReplicaId"
            },
            "CurrentReplicatorOperation": {
              "$ref": "#/definitions/ReplicatorOperationName"
            },
            "ReadStatus": {
              "$ref": "#/definitions/PartitionAccessStatus"
            },
            "WriteStatus": {
              "$ref": "#/definitions/PartitionAccessStatus"
            },
            "ReplicatorStatus": {
              "$ref": "#/definitions/ReplicatorStatus"
            },
            "ReplicaStatus": {
              "$ref": "#/definitions/KeyValueStoreReplicaStatus"
            },
            "DeployedServiceReplicaQueryResult": {
              "$ref": "#/definitions/DeployedStatefulServiceReplicaInfo"
            }
          }
        }
      ]
    },
    "DeployedStatelessServiceInstanceDetailInfo": {
      "description": "Information about a stateless instance running in a code package. Please note that DeployedServiceReplicaQueryResult will contain duplicate data like ServiceKind, ServiceName, PartitionId and InstanceId.",
      "x-ms-discriminator-value": "Stateless",
      "allOf": [
        {
          "$ref": "#/definitions/DeployedServiceReplicaDetailInfo"
        },
        {
          "type": "object",
          "description": "DeployedStatelessServiceInstanceDetailInfo",
          "properties": {
            "InstanceId": {
              "$ref": "#/definitions/InstanceId"
            },
            "DeployedServiceReplicaQueryResult": {
              "$ref": "#/definitions/DeployedStatelessServiceInstanceInfo"
            }
          }
        }
      ]
    },
    "FabricReplicaStatus": {
      "type": "string",
      "description": "Specifies the status of the replica. Possible values are following.\n  - Invalid - Indicates that the read or write operation access status is not valid. This value is not returned to the caller.\n  - Down - Indicates that the replica is down.\n  - Up - Indicates that the replica is up.\n",
      "enum": [
        "Invalid",
        "Down",
        "Up"
      ]
    },
    "LoadMetricReportInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/LoadMetricReportInfo"
      },
      "description": "List of load reported by replica."
    },
    "LoadMetricReportInfo": {
      "type": "object",
      "description": "Information about load reported by replica.",
      "properties": {
        "Name": {
          "type": "string",
          "description": "The name of the metric."
        },
        "Value": {
          "type": "integer",
          "format": "int32",
          "description": "The value of the load for the metric.."
        },
        "LastReportedUtc": {
          "type": "string",
          "format": "date-time",
          "description": "The UTC time when the load is reported."
        }
      }
    },
    "PartitionAccessStatus": {
      "type": "string",
      "description": "Specifies the access status of the partition. Possible values are following.\n  - Invalid - Indicates that the read or write operation access status is not valid. This value is not returned to the caller.\n  - Granted - Indicates that the read or write operation access is granted and the operation is allowed.\n  - ReconfigurationPending - Indicates that the client should try again later, because a reconfiguration is in progress.\n  - NotPrimary - Indicates that this client request was received by a replica that is not a Primary replica.\n  - NoWriteQuorum - Indicates that no write quorum is available and, therefore, no write operation can be accepted.\n",
      "enum": [
        "Invalid",
        "Granted",
        "ReconfigurationPending",
        "NotPrimary",
        "NoWriteQuorum"
      ]
    },
    "ReplicatorOperationName": {
      "type": "string",
      "description": "Specifies the operation currently being executed by the Replicator. Possible values are following.\n  - Invalid - Default value if the replicator is not yet ready.\n  - None - Replicator is not running any operation from Service Fabric perspective.\n  - Open - Replicator is opening.\n  - ChangeRole - Replicator is in the process of changing its role.\n  - UpdateEpoch - Due to a change in the replica set, replicator is being updated with its Epoch.\n  - Close - Replicator is closing.\n  - Abort - Replicator is being aborted.\n  - OnDataLoss - Replicator is handling the data loss condition, where the user service may potentially be recovering state from an external source.\n  - WaitForCatchup - Replicator is waiting for a quorum of replicas to be caught up to the latest state.\n  - Build - Replicator is in the process of building one or more replicas.\n",
      "enum": [
        "Invalid",
        "None",
        "Open",
        "ChangeRole",
        "UpdateEpoch",
        "Close",
        "Abort",
        "OnDataLoss",
        "WaitForCatchup",
        "Build"
      ]
    },
    "ServiceOperationName": {
      "type": "string",
      "description": "Specifies the current active life-cycle operation on a stateful service replica or stateless service instance. Possible values are following.\n  - Unknown - Reserved for future use.\n  - None - The service replica or instance is not going through any life-cycle changes.\n  - Open - The service replica or instance is being opened.\n  - ChangeRole - The service replica is changing roles.\n  - Close - The service replica or instance is being closed.\n  - Abort - The service replica or instance is being aborted.\n",
      "enum": [
        "Unknown",
        "None",
        "Open",
        "ChangeRole",
        "Close",
        "Abort"
      ]
    },
    "ReplicaKind": {
      "type": "string",
      "description": "The role of a replica of a stateful service. Possible values are following.\n  - Invalid - Represents an invalid replica kind. The value is zero.\n  - KeyValueStore - Represents a key value store replica. The value is 1\n",
      "enum": [
        "Invalid",
        "KeyValueStore"
      ]
    },
    "ReplicaStatusBase": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Information about the replica.",
      "required": [
        "Kind"
      ],
      "properties": {
        "Kind": {
          "$ref": "#/definitions/ReplicaKind"
        }
      }
    },
    "KeyValueStoreReplicaStatus": {
      "description": "Key value store related information for the replica.",
      "x-ms-discriminator-value": "KeyValueStore",
      "allOf": [
        {
          "$ref": "#/definitions/ReplicaStatusBase"
        },
        {
          "type": "object",
          "description": "KeyValueStoreReplicaStatus",
          "properties": {
            "DatabaseRowCountEstimate": {
              "type": "string",
              "description": "Value indicating the estimated number of rows in the underlying database."
            },
            "DatabaseLogicalSizeEstimate": {
              "type": "string",
              "description": "Value indicating the estimated size of the underlying database."
            },
            "CopyNotificationCurrentKeyFilter": {
              "type": "string",
              "description": "Value indicating the latest key-prefix filter applied to enumeration during the callback. Null if there is no pending callback."
            },
            "CopyNotificationCurrentProgress": {
              "type": "string",
              "description": "Value indicating the latest number of keys enumerated during the callback. 0 if there is no pending callback."
            },
            "StatusDetails": {
              "type": "string",
              "description": "Value indicating the current status details of the replica."
            }
          }
        }
      ]
    },
    "ServiceUpdateDescription": {
      "type": "object",
      "discriminator": "ServiceKind",
      "description": "A ServiceUpdateDescription contains all of the information necessary to update a service.",
      "required": [
        "ServiceKind"
      ],
      "properties": {
        "ServiceKind": {
          "$ref": "#/definitions/ServiceKind"
        },
        "Flags": {
          "type": "string",
          "description": "Flags indicating whether other properties are set. Each of the associated properties corresponds to a flag, specified below, which, if set, indicate that the property is specified.\nThis property can be a combination of those flags obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.\n\n- None - Does not indicate any other properties are set. The value is zero.\n- TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property (for Stateful services) or the InstanceCount property (for Stateless services) is set. The value is 1.\n- ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The value is  2.\n- QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is 4.\n- StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The value is 8.\n- MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.\n- PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.\n- PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is 64.\n- Correlation - Indicates the CorrelationScheme property is set. The value is 128.\n- Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.\n- DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.\n"
        },
        "PlacementConstraints": {
          "type": "string",
          "description": "The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: \"NodeColor == blue)\"."
        },
        "CorrelationScheme": {
          "$ref": "#/definitions/CorrelationSchemeList"
        },
        "LoadMetrics": {
          "$ref": "#/definitions/ServiceLoadMetricsList"
        },
        "ServicePlacementPolicies": {
          "$ref": "#/definitions/ServicePlacementPoliciesList"
        },
        "DefaultMoveCost": {
          "$ref": "#/definitions/MoveCost"
        }
      }
    },
    "StatefulServiceUpdateDescription": {
      "description": "Describes an update for a stateful service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceUpdateDescription"
        },
        {
          "type": "object",
          "description": "StatefulServiceUpdateDescription"
        }
      ],
      "x-ms-discriminator-value": "Stateful",
      "properties": {
        "TargetReplicaSetSize": {
          "type": "integer",
          "minimum": 1,
          "description": "The target replica set size as a number."
        },
        "MinReplicaSetSize": {
          "type": "integer",
          "minimum": 1,
          "description": "The minimum replica set size as a number."
        },
        "ReplicaRestartWaitDurationSeconds": {
          "type": "string",
          "description": "The duration, in seconds, between when a replica goes down and when a new replica is created."
        },
        "QuorumLossWaitDurationSeconds": {
          "type": "string",
          "description": "The maximum duration, in seconds, for which a partition is allowed to be in a state of quorum loss."
        },
        "StandByReplicaKeepDurationSeconds": {
          "type": "string",
          "description": "The definition on how long StandBy replicas should be maintained before being removed."
        }
      }
    },
    "StatelessServiceUpdateDescription": {
      "description": "Describes an update for a stateless service.",
      "allOf": [
        {
          "$ref": "#/definitions/ServiceUpdateDescription"
        },
        {
          "type": "object",
          "description": "StatelessServiceUpdateDescription"
        }
      ],
      "x-ms-discriminator-value": "Stateless",
      "properties": {
        "InstanceCount": {
          "type": "integer",
          "minimum": -1,
          "description": "The instance count."
        }
      }
    },
    "ImageStoreRelativePath": {
      "type": "string",
      "description": "The remote location within image store. This path is relative to the image store root."
    },
    "FileVersion": {
      "type": "object",
      "description": "Information about the version of image store file.",
      "properties": {
        "VersionNumber": {
          "type": "string",
          "description": "The current iamge store version number for the file is used in image store for checking whether it need to be updated."
        },
        "EpochDataLossNumber": {
          "type": "string",
          "description": "The epoch data loss number of image store file is used to indicate the status of data loss."
        }
      }
    },
    "FileInfo": {
      "type": "object",
      "description": "Information about a image store file.",
      "properties": {
        "FileSize": {
          "type": "string",
          "description": "The size of file in bytes."
        },
        "FileVersion": {
          "$ref": "#/definitions/FileVersion"
        },
        "ModifiedDate": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time when the image store file was last modified."
        },
        "StoreRelativePath": {
          "type": "string",
          "description": "The file path relative to the image store root path."
        }
      }
    },
    "FolderInfo": {
      "type": "object",
      "description": "Information about a image store folder. It inclues how many files this folder contains and its image store relative path.",
      "properties": {
        "StoreRelativePath": {
          "$ref": "#/definitions/ImageStoreRelativePath"
        },
        "FileCount": {
          "type": "string",
          "format": "uuid",
          "description": "The number of files from within the image store folder."
        }
      }
    },
    "ImageStoreContent": {
      "type": "object",
      "description": "Information about the image store content.",
      "properties": {
        "StoreFiles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FileInfo"
          },
          "description": "The list of image store file info objects represents files found under the given image store relative path."
        },
        "StoreFolders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FolderInfo"
          },
          "description": "The list of image store folder info objectes represents subfolders found under the given image store relative path."
        }
      }
    },
    "ImageStoreCopyDescription": {
      "type": "object",
      "description": "Information about how to copy image store content from one image store relative path to another image store relative path.",
      "required": [
        "RemoteSource",
        "RemoteDestination"
      ],
      "properties": {
        "RemoteSource": {
          "type": "string",
          "description": "The relative path of source image store content to be copied from."
        },
        "RemoteDestination": {
          "type": "string",
          "description": "The relative path of destination image store content to be copied to."
        },
        "SkipFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The list of the file names to be skipped for copying."
        },
        "CheckMarkFile": {
          "type": "boolean",
          "description": "Indicates whether to check mark file during copying. The property is true if checking mark file is required, false otherwise. The mark file is used to check whether the folder is well constructed. If the property is true and mark file does not exist, the copy is skipped."
        }
      }
    },
    "InstanceId": {
      "type": "string",
      "description": "Id of a stateless service instance. InstanceId is used by Service Fabric to uniquely identify an instance of a partition of a stateless service. It is unique within a partition and does not change for the lifetime of the instance. If the instance is failedover on the same or different node, it will get a different value for the InstanceId."
    },
    "CodePackageInstanceId": {
      "type": "string",
      "description": "The instance id for current running entry point. For a code package setup entry point (if specified) runs first and after it finishes main entry point is started. Each time entry point executable is run, its instance id will change."
    },
    "HostIsolationMode": {
      "type": "string",
      "description": "Specifies the isolation mode of main entry point of a code package when it's host type is ContainerHost. This is specified as part of container host policies in application manifest while importing service manifest. Possible values are following.\n\n  - None - Indicates the isolation mode is not applicable for given HostType. The value is 0.\n  - Process - This is the default isolation mode for a ContainerHost. The value is 1.\n  - HyperV - Indicates the ContainerHost is a Hyper-V container. This applies to only Windows containers. The value is 2.\n",
      "enum": [
        "None",
        "Process",
        "HyperV"
      ]
    },
    "HostType": {
      "type": "string",
      "description": "Specifies the type of host for main entry point of a code package as specified in service manifest. Possible values are following.\n\n  - Invalid - Indicates the type of host is not known or invalid. The value is 0.\n  - ExeHost - Indicates the host is an executable. The value is 1.\n  - ContainerHost - Indicates the host is a container. The value is 2.\n",
      "enum": [
        "Invalid",
        "ExeHost",
        "ContainerHost"
      ]
    },
    "RestartDeployedCodePackageDescription": {
      "type": "object",
      "description": "Defines description for restarting a deloyed code package on Service Fabric node.\n",
      "required": [
        "ServiceManifestName",
        "CodePackageName",
        "CodePackageInstanceId"
      ],
      "properties": {
        "ServiceManifestName": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "ServicePackageActivationId": {
          "$ref": "#/definitions/ServicePackageActivationId"
        },
        "CodePackageName": {
          "$ref": "#/definitions/CodePackageName"
        },
        "CodePackageInstanceId": {
          "$ref": "#/definitions/CodePackageInstanceId"
        }
      }
    },
    "DeployedServiceTypeInfo": {
      "type": "object",
      "description": "Information about service type deployed on a node, information such as the status of the service type registration on a node.",
      "properties": {
        "ServiceTypeName": {
          "$ref": "#/definitions/ServiceTypeName"
        },
        "ServiceManifestName": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "CodePackageName": {
          "$ref": "#/definitions/CodePackageName"
        },
        "Status": {
          "$ref": "#/definitions/ServiceTypeRegistrationStatus"
        },
        "ServicePackageActivationId": {
          "$ref": "#/definitions/ServicePackageActivationId"
        }
      }
    },
    "DeployedServiceTypeInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/DeployedServiceTypeInfo"
      },
      "description": "List of information about service type deployed on a node."
    },
    "ServiceTypeRegistrationStatus": {
      "type": "string",
      "description": "The status of the service type registration on the node. Possible values are following.\n\n  - Invalid - Indicates the registration status is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Disabled - Indicates that the service type is disabled on this node. A type gets disabled when there are too many failures of the code package hosting the service type. If the service type is disabled, new replicas of that service type will not be placed on the node until it is enabled again. The service type is enabled again after the process hosting it comes up and re-registers the type or a preconfigured time interval has passed. The value is 1.\n  - Enabled - Indicates that the service type is enabled on this node. Replicas of this service type can be placed on this node when the code package registeres the service type. The value is 2.\n  - Registered - Indicates that the sevice type is enabled and registered on the node by a code package. Replicas of this service type can now be olaced on this node. The value is 3.\n",
      "enum": [
        "Invalid",
        "Disabled",
        "Enabled",
        "Registered"
      ]
    },
    "ServiceEndpointRole": {
      "type": "string",
      "description": "The role of the replica where the endpoint is reported. Possible values are following.\n\n  - Invalid - Indicates the service endpoint role is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Stateless - Indicates that the service endpoint is of a stateless service. The value is 1.\n  - StatefulPrimary - Indicates that the service endpoint is of a primary replica of a stateful service. The value is 2.\n  - StatefulSecondary -  Indicates that the service endpoint is of a secondary replica of a stateful service. The value is 3.\n",
      "enum": [
        "Invalid",
        "Stateless",
        "StatefulPrimary",
        "StatefulSecondary"
      ]
    },
    "ResolvedServiceEndpoint": {
      "type": "object",
      "description": "Endpoint of a resolved service partition.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/ServiceEndpointRole"
        },
        "Address": {
          "type": "string",
          "description": "The address of the endpoint. If the endpoint has multiple listeners the address is a JSON object with one property per listener with the value as the address of that listener."
        }
      }
    },
    "ResolvedServicePartition": {
      "type": "object",
      "description": "Information about a service partition and its associated endpoints.",
      "required": [
        "Name",
        "PartitionInformation",
        "Endpoints",
        "Version"
      ],
      "properties": {
        "Name": {
          "$ref": "#/definitions/ServiceName"
        },
        "PartitionInformation": {
          "$ref": "#/definitions/PartitionInformation"
        },
        "Endpoints": {
          "$ref": "#/definitions/ResolvedServiceEndpointList"
        },
        "Version": {
          "type": "string",
          "description": "The version of this resolved service partition result. This version should be passed in the next time the ResolveService call is made via the PreviousRspVersion query parameter."
        }
      }
    },
    "ResolvedServiceEndpointList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ResolvedServiceEndpoint"
      },
      "description": "List of resolved service endpoints of a service partition."
    },
    "InvokeDataLossResult": {
      "type": "object",
      "description": "Represents information about an operation in a terminal state (Completed or Faulted).",
      "properties": {
        "ErrorCode": {
          "type": "integer",
          "format": "int32",
          "description": "If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error code indicating the reason."
        },
        "SelectedPartition": {
          "$ref": "#/definitions/SelectedPartition"
        }
      }
    },
    "InvokeQuorumLossResult": {
      "type": "object",
      "description": "Represents information about an operation in a terminal state (Completed or Faulted).",
      "properties": {
        "ErrorCode": {
          "type": "integer",
          "format": "int32",
          "description": "If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error code indicating the reason."
        },
        "SelectedPartition": {
          "$ref": "#/definitions/SelectedPartition"
        }
      }
    },
    "NodeResult": {
      "type": "object",
      "description": "Contains information about a node that was targeted by a user-induced operation.",
      "properties": {
        "NodeName": {
          "$ref": "#/definitions/NodeName"
        },
        "NodeInstanceId": {
          "type": "string",
          "description": "The node instance id."
        }
      }
    },
    "NodeTransitionProgress": {
      "type": "object",
      "description": "Information about an NodeTransition operation.  This class contains an OperationState and a NodeTransitionResult.  The NodeTransitionResult is not valid until OperationState\nis Completed or Faulted.\n",
      "properties": {
        "State": {
          "$ref": "#/definitions/OperationState"
        },
        "NodeTransitionResult": {
          "$ref": "#/definitions/NodeTransitionResult"
        }
      }
    },
    "NodeTransitionResult": {
      "type": "object",
      "description": "Represents information about an operation in a terminal state (Completed or Faulted).",
      "properties": {
        "ErrorCode": {
          "type": "integer",
          "format": "int32",
          "description": "If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error code indicating the reason."
        },
        "NodeResult": {
          "$ref": "#/definitions/NodeResult"
        }
      }
    },
    "OperationId": {
      "type": "string",
      "format": "uuid",
      "description": "A GUID that identifies a call to this API.  This is also passed into the corresponding GetProgress API."
    },
    "OperationState": {
      "type": "string",
      "description": "- Invalid - The operation state is invalid.\n- Running - The operation is in progress.\n- RollingBack -  The operation is rolling back internal system state because it encountered a fatal error or was cancelled by the user.  \"RollingBack\"\n   does not refer to user state.  For example, if CancelOperation is called on a command of type PartitionDataLoss,\n   a state of \"RollingBack\" does not mean service data is being restored (assuming the command has progressed far enough to cause data loss).\n   It means the system is rolling back/cleaning up internal system state associated with the command.\n- Completed - The operation has completed successfully and is no longer running.\n- Faulted - The operation has failed and is no longer running.\n- Cancelled - The operation was cancelled by the user using CancelOperation, and is no longer running.\n- ForceCancelled - The operation was cancelled by the user using CancelOperation, with the force parameter set to true.  It is no longer running.  Refer to CancelOperation for more details.\n",
      "enum": [
        "Invalid",
        "Running",
        "RollingBack",
        "Completed",
        "Faulted",
        "Cancelled",
        "ForceCancelled"
      ]
    },
    "OperationStatus": {
      "type": "object",
      "description": "Contains the OperationId, OperationState, and OperationType for user-induced operations.",
      "properties": {
        "OperationId": {
          "$ref": "#/definitions/OperationId"
        },
        "State": {
          "$ref": "#/definitions/OperationState"
        },
        "Type": {
          "$ref": "#/definitions/OperationType"
        }
      }
    },
    "OperationStatusList": {
      "type": "array",
      "description": "A list of OperationStatus objects.",
      "items": {
        "$ref": "#/definitions/OperationStatus"
      }
    },
    "OperationType": {
      "type": "string",
      "description": "- Invalid - The operation state is invalid.\n- PartitionDataLoss - An operation started using the StartDataLoss API.\n- PartitionQuorumLoss - An operation started using the StartQuorumLoss API.\n- PartitionRestart - An operation started using the StartPartitionRestart API.\n- NodeTransition - An operation started using the StartNodeTransition API.\n",
      "enum": [
        "Invalid",
        "PartitionDataLoss",
        "PartitionQuorumLoss",
        "PartitionRestart",
        "NodeTransition"
      ]
    },
    "PartitionDataLossProgress": {
      "type": "object",
      "description": "Information about a partition data loss user-induced operation.",
      "properties": {
        "State": {
          "$ref": "#/definitions/OperationState"
        },
        "InvokeDataLossResult": {
          "$ref": "#/definitions/InvokeDataLossResult"
        }
      }
    },
    "PartitionQuorumLossProgress": {
      "type": "object",
      "description": "Information about a partition quorum loss user-induced operation.",
      "properties": {
        "State": {
          "$ref": "#/definitions/OperationState"
        },
        "InvokeQuorumLossResult": {
          "$ref": "#/definitions/InvokeQuorumLossResult"
        }
      }
    },
    "PartitionRestartProgress": {
      "type": "object",
      "description": "Information about a partition restart user-induced operation.",
      "properties": {
        "State": {
          "$ref": "#/definitions/OperationState"
        },
        "RestartPartitionResult": {
          "$ref": "#/definitions/RestartPartitionResult"
        }
      }
    },
    "RestartPartitionResult": {
      "type": "object",
      "description": "Represents information about an operation in a terminal state (Completed or Faulted).",
      "properties": {
        "ErrorCode": {
          "type": "integer",
          "format": "int32",
          "description": "If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error code indicating the reason."
        },
        "SelectedPartition": {
          "$ref": "#/definitions/SelectedPartition"
        }
      }
    },
    "SelectedPartition": {
      "type": "object",
      "description": "This class returns information about the partition that the user-induced operation acted upon.",
      "properties": {
        "ServiceName": {
          "$ref": "#/definitions/ServiceName"
        },
        "PartitionId": {
          "$ref": "#/definitions/PartitionId"
        }
      }
    },
    "DeployServicePackageToNodeDescription": {
      "type": "object",
      "description": "Defines description for downloading packages associated with a service manifest to image cache on a Service Fabric node.\n",
      "properties": {
        "ServiceManifestName": {
          "$ref": "#/definitions/ServiceManifestName"
        },
        "ApplicationTypeName": {
          "$ref": "#/definitions/ApplicationTypeName"
        },
        "ApplicationTypeVersion": {
          "$ref": "#/definitions/ApplicationTypeVersion"
        },
        "NodeName": {
          "$ref": "#/definitions/NodeName"
        },
        "PackageSharingPolicy": {
          "$ref": "#/definitions/PackageSharingPolicyInfoList"
        }
      },
      "required": [
        "ServiceManifestName",
        "ApplicationTypeName",
        "ApplicationTypeVersion",
        "NodeName"
      ]
    },
    "PackageSharingPolicyInfo": {
      "type": "object",
      "description": "Represents a policy for the package sharing.",
      "properties": {
        "SharedPackageName": {
          "type": "string",
          "description": "The name of code, configuration or data package that should be shared."
        },
        "PackageSharingScope": {
          "$ref": "#/definitions/PackageSharingPolicyScope"
        }
      }
    },
    "PackageSharingPolicyInfoList": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/PackageSharingPolicyInfo"
      },
      "description": "List of package sharing policy information."
    },
    "PackageSharingPolicyScope": {
      "type": "string",
      "description": "Represents the scope for PackageSharingPolicy. This is specified during DeployServicePackageToNode operation. Possible values are following.\n\n  - None - No package sharing policy scope. The value is 0.\n  - All - Share all code, config and data packages from corresponding service manifest. The value is 1.\n  - Code - Share all code packages from corresponding service manifest. The value is 2.\n  - Config - Share all config packages from corresponding service manifest. The value is 3.\n  - Data - Share all data packages from corresponding service manifest. The value is 4.\n",
      "enum": [
        "None",
        "All",
        "Code",
        "Config",
        "Data"
      ]
    },
    "ResumeApplicationUpgradeDescription": {
      "type": "object",
      "description": "Describes the parameters for resuming an unmonitored manual Service Fabric application upgrade",
      "properties": {
        "UpgradeDomainName": {
          "type": "string",
          "description": "The name of the upgrade domain in which to resume the upgrade."
        }
      },
      "required": [
        "UpgradeDomainName"
      ]
    },
    "ApplicationUpgradeUpdateDescription": {
      "type": "object",
      "description": "Describes the parameters for updating an ongoing application upgrade.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/ApplicationName"
        },
        "UpgradeKind": {
          "$ref": "#/definitions/UpgradeKind"
        },
        "ApplicationHealthPolicy": {
          "$ref": "#/definitions/ApplicationHealthPolicy"
        },
        "UpdateDescription": {
          "$ref": "#/definitions/RollingUpgradeUpdateDescription"
        }
      },
      "required": [
        "Name",
        "UpgradeKind"
      ]
    },
    "RollingUpgradeUpdateDescription": {
      "type": "object",
      "description": "Describes the parameters for updating a rolling upgrade of application or cluster.",
      "properties": {
        "RollingUpgradeMode": {
          "$ref": "#/definitions/UpgradeMode"
        },
        "ForceRestart": {
          "$ref": "#/definitions/ForceRestart"
        },
        "ReplicaSetCheckTimeoutInMilliseconds": {
          "$ref": "#/definitions/UpgradeReplicaSetCheckTimeout"
        },
        "FailureAction": {
          "$ref": "#/definitions/FailureAction"
        },
        "HealthCheckWaitDurationInMilliseconds": {
          "$ref": "#/definitions/HealthCheckWaitDuration"
        },
        "HealthCheckStableDurationInMilliseconds": {
          "$ref": "#/definitions/HealthCheckStableDuration"
        },
        "HealthCheckRetryTimeoutInMilliseconds": {
          "$ref": "#/definitions/HealthCheckRetryTimeout"
        },
        "UpgradeTimeoutInMilliseconds": {
          "$ref": "#/definitions/UpgradeTimeout"
        },
        "UpgradeDomainTimeoutInMilliseconds": {
          "$ref": "#/definitions/UpgradeDomainTimeout"
        }
      },
      "required": [
        "RollingUpgradeMode"
      ]
    },
    "NameDescription": {
      "type": "object",
      "description": "Describes a Service Fabric name.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/FabricName"
        }
      },
      "required": [
        "Name"
      ]
    },
    "FabricName": {
      "type": "string",
      "description": "The Service Fabric name, including the 'fabric:' URI scheme."
    },
    "PagedSubNameInfoList": {
      "type": "object",
      "description": "A paged list of Service Fabric names. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "IsConsistent": {
          "type": "boolean",
          "description": "Indicates whether any name under the given name has been modified during the enumeration. If there was a modification, this property value is false."
        },
        "SubNames": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FabricName"
          }
        }
      }
    },
    "PropertyValueKind": {
      "type": "string",
      "description": "The kind of property, determined by the type of data. Following are the possible values.\n\n- Invalid - Indicates the property is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n- Binary - The data inside the property is a binary blob. The value is 1.\n- Int64 - The data inside the property is an int64. The value is 2.\n- Double - The data inside the property is a double. The value is 3.\n- String - The data inside the property is a wstring. The value is 4.\n- Guid - The data inside the property is a guid. The value is 5.\n",
      "enum": [
        "Invalid",
        "Binary",
        "Int64",
        "Double",
        "String",
        "Guid"
      ]
    },
    "PropertyValue": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Describes a Service Fabric property value.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/PropertyValueKind"
        }
      },
      "required": [
        "Kind"
      ]
    },
    "BinaryPropertyValue": {
      "description": "Describes a Service Fabric property value of type Binary.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyValue"
        },
        {
          "type": "object",
          "description": "BinaryPropertyValue"
        }
      ],
      "x-ms-discriminator-value": "Binary",
      "required": [
        "Data"
      ],
      "properties": {
        "Data": {
          "$ref": "#/definitions/ByteArray"
        }
      }
    },
    "Int64PropertyValue": {
      "description": "Describes a Service Fabric property value of type Int64.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyValue"
        },
        {
          "type": "object",
          "description": "Int64PropertyValue"
        }
      ],
      "x-ms-discriminator-value": "Int64",
      "required": [
        "Data"
      ],
      "properties": {
        "Data": {
          "type": "string",
          "format": "int64",
          "description": "The data of the property value."
        }
      }
    },
    "DoublePropertyValue": {
      "description": "Describes a Service Fabric property value of type Double.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyValue"
        },
        {
          "type": "object",
          "description": "DoublePropertyValue"
        }
      ],
      "x-ms-discriminator-value": "Double",
      "required": [
        "Data"
      ],
      "properties": {
        "Data": {
          "type": "number",
          "format": "double",
          "description": "The data of the property value."
        }
      }
    },
    "StringPropertyValue": {
      "description": "Describes a Service Fabric property value of type String.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyValue"
        },
        {
          "type": "object",
          "description": "StringPropertyValue"
        }
      ],
      "x-ms-discriminator-value": "String",
      "required": [
        "Data"
      ],
      "properties": {
        "Data": {
          "type": "string",
          "description": "The data of the property value."
        }
      }
    },
    "GuidPropertyValue": {
      "description": "Describes a Service Fabric property value of type Guid.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyValue"
        },
        {
          "type": "object",
          "description": "GuidPropertyValue"
        }
      ],
      "x-ms-discriminator-value": "Guid",
      "required": [
        "Data"
      ],
      "properties": {
        "Data": {
          "type": "string",
          "format": "uuid",
          "description": "The data of the property value."
        }
      }
    },
    "PropertyInfo": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Information about a Service Fabric property.",
      "properties": {
        "Name": {
          "$ref": "#/definitions/PropertyName"
        },
        "Value": {
          "$ref": "#/definitions/PropertyValue"
        },
        "Metadata": {
          "$ref": "#/definitions/PropertyMetadata"
        }
      },
      "required": [
        "Name",
        "Metadata"
      ]
    },
    "PagedPropertyInfoList": {
      "type": "object",
      "description": "The paged list of Service Fabric properties under a given name. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.",
      "properties": {
        "ContinuationToken": {
          "$ref": "#/definitions/ContinuationToken"
        },
        "IsConsistent": {
          "type": "boolean",
          "description": "Indicates whether any property under the given name has been modified during the enumeration. If there was a modification, this property value is false."
        },
        "Properties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyInfo"
          }
        }
      }
    },
    "PropertyDescription": {
      "type": "object",
      "description": "Description of a Service Fabric property.",
      "properties": {
        "PropertyName": {
          "$ref": "#/definitions/PropertyName"
        },
        "CustomTypeId": {
          "$ref": "#/definitions/PropertyCustomTypeId"
        },
        "Value": {
          "$ref": "#/definitions/PropertyValue"
        }
      },
      "required": [
        "PropertyName",
        "Value"
      ]
    },
    "PropertyName": {
      "type": "string",
      "description": "The name of the Service Fabric property."
    },
    "PropertyMetadata": {
      "type": "object",
      "description": "The metadata associated with a property, including the property's name.",
      "properties": {
        "TypeId": {
          "$ref": "#/definitions/PropertyValueKind"
        },
        "CustomTypeId": {
          "$ref": "#/definitions/PropertyCustomTypeId"
        },
        "Parent": {
          "$ref": "#/definitions/FabricName"
        },
        "SizeInBytes": {
          "type": "integer",
          "description": "The length of the serialized property value."
        },
        "LastModifiedUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Represents when the Property was last modified. Only write operations will cause this field to be updated."
        },
        "SequenceNumber": {
          "type": "string",
          "format": "int64",
          "description": "The version of the property. Every time a property is modified, its sequence number is increased."
        }
      }
    },
    "PropertyCustomTypeId": {
      "type": "string",
      "description": "The property's custom type id. Using this property, the user is able to tag the type of the value of the property."
    },
    "PropertyBatchDescriptionList": {
      "type": "object",
      "description": "Describes a list of property batch operations to be executed. Either all or none of the operations will be committed.",
      "properties": {
        "Operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyBatchOperation"
          },
          "description": "A list of the property batch operations to be executed."
        }
      }
    },
    "PropertyBatchOperationKind": {
      "type": "string",
      "description": "The kind of property batch operation, determined by the operation to be performed. The following are the possible values.\n\n- Invalid - Indicates the property operation is invalid. All Service Fabric enumerations have the invalid type. The value is zero.\n- Put - The operation will create or edit a property. The value is 1.\n- Get - The operation will get a property. The value is 2.\n- CheckExists - The operation will check that a property exists or doesn't exists, depending on the provided value. The value is 3.\n- CheckSequence - The operation will ensure that the sequence number is equal to the provided value. The value is 4.\n- Delete - The operation will delete a property. The value is 5.\n- CheckValue - The operation will ensure that the value of a property is equal to the provided value. The value is 7.\n",
      "enum": [
        "Invalid",
        "Put",
        "Get",
        "CheckExists",
        "CheckSequence",
        "Delete",
        "CheckValue"
      ]
    },
    "PropertyBatchOperation": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Represents the base type for property operations that can be put into a batch and submitted.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/PropertyBatchOperationKind"
        },
        "PropertyName": {
          "$ref": "#/definitions/PropertyName"
        }
      },
      "required": [
        "Kind",
        "PropertyName"
      ]
    },
    "CheckExistsPropertyBatchOperation": {
      "description": "Represents a PropertyBatchOperation that compares the Boolean existence of a property with the Exists argument.  The PropertyBatchOperation operation fails if the property's existence is not equal to the Exists argument.  The CheckExistsPropertyBatchOperation is generally used as a precondition for the write operations in the batch.  Note that if one PropertyBatchOperation in a PropertyBatch fails,  the entire batch fails and cannot be committed in a transactional manner.\n",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchOperation"
        },
        {
          "type": "object",
          "description": "CheckExistsPropertyBatchOperation"
        }
      ],
      "x-ms-discriminator-value": "CheckExists",
      "properties": {
        "Exists": {
          "type": "boolean",
          "description": "Whether or not the property should exist for the operation to pass."
        }
      },
      "required": [
        "Exists"
      ]
    },
    "CheckSequencePropertyBatchOperation": {
      "description": "Compares the Sequence Number of a property with the SequenceNumber argument.  A property's sequence number can be thought of as that property's version.  Every time the property is modified, its sequence number is increased.  The sequence number can be found in a property's metadata.  The comparison fails if the sequence numbers are not equal.  CheckSequencePropertyBatchOperation is generally used as a precondition for the write operations in the batch.  Note that if one PropertyBatchOperation in a PropertyBatch fails,  the entire batch fails and cannot be committed in a transactional manner.\n",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchOperation"
        },
        {
          "type": "object",
          "description": "CheckSequencePropertyBatchOperation"
        }
      ],
      "x-ms-discriminator-value": "CheckSequence",
      "properties": {
        "SequenceNumber": {
          "type": "string",
          "format": "int64",
          "description": "The expected sequence number."
        }
      },
      "required": [
        "SequenceNumber"
      ]
    },
    "CheckValuePropertyBatchOperation": {
      "description": "Represents a PropertyBatchOperation that compares the value of the property with the expected value.  The CheckValuePropertyBatchOperation is generally used as a precondition for the write operations in the batch.  Note that if one PropertyBatchOperation in a PropertyBatch fails,  the entire batch fails and cannot be committed in a transactional manner.\n",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchOperation"
        },
        {
          "type": "object",
          "description": "CheckValuePropertyBatchOperation"
        }
      ],
      "x-ms-discriminator-value": "CheckValue",
      "properties": {
        "Value": {
          "$ref": "#/definitions/PropertyValue"
        }
      },
      "required": [
        "Value"
      ]
    },
    "DeletePropertyBatchOperation": {
      "description": "Represents a PropertyBatchOperation that deletes a specified property if it exists.  Note that if one PropertyBatchOperation in a PropertyBatch fails,  the entire batch fails and cannot be committed in a transactional manner.\n",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchOperation"
        },
        {
          "type": "object",
          "description": "DeletePropertyBatchOperation"
        }
      ],
      "x-ms-discriminator-value": "Delete"
    },
    "GetPropertyBatchOperation": {
      "description": "Represents a PropertyBatchOperation that gets the specified property if it exists.  Note that if one PropertyBatchOperation in a PropertyBatch fails,  the entire batch fails and cannot be committed in a transactional manner.\n",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchOperation"
        },
        {
          "type": "object",
          "description": "GetPropertyBatchOperation"
        }
      ],
      "x-ms-discriminator-value": "Get",
      "properties": {
        "IncludeValue": {
          "type": "boolean",
          "default": false,
          "description": "Whether or not to return the property value with the metadata.  True if values should be returned with the metadata; False to return only property metadata.\n"
        }
      }
    },
    "PutPropertyBatchOperation": {
      "description": "Puts the specified property under the specified name.  Note that if one PropertyBatchOperation in a PropertyBatch fails,  the entire batch fails and cannot be committed in a transactional manner.\n",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchOperation"
        },
        {
          "type": "object",
          "description": "PutPropertyBatchOperation"
        }
      ],
      "x-ms-discriminator-value": "Put",
      "properties": {
        "Value": {
          "$ref": "#/definitions/PropertyValue"
        },
        "CustomTypeId": {
          "$ref": "#/definitions/PropertyCustomTypeId"
        }
      },
      "required": [
        "Value"
      ]
    },
    "PropertyBatchInfoKind": {
      "type": "string",
      "description": "The kind of property batch info, determined by the results of a property batch. The following are the possible values.\n\n- Invalid - Indicates the property batch info is invalid. All Service Fabric enumerations have the invalid type.\n- Successful - The property batch succeeded.\n- Failed - The property batch failed.\n",
      "enum": [
        "Invalid",
        "Successful",
        "Failed"
      ]
    },
    "PropertyBatchInfo": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Information about the results of a property batch.",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/PropertyBatchInfoKind"
        }
      },
      "required": [
        "Kind"
      ]
    },
    "SuccessfulPropertyBatchInfo": {
      "description": "Derived from PropertyBatchInfo. Represents the property batch succeeding. Contains the results of any \"Get\" operations in the batch.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchInfo"
        },
        {
          "type": "object",
          "description": "SuccessfulPropertyBatchInfo"
        }
      ],
      "x-ms-discriminator-value": "Successful",
      "properties": {
        "Properties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/PropertyInfo"
          },
          "description": "A map containing the properties that were requested through any \"Get\" property batch operations. The key represents the index of the \"Get\" operation in the original request, in string form. The value is the property. If a property is not found, it will not be in the map."
        }
      }
    },
    "FailedPropertyBatchInfo": {
      "description": "Derived from PropertyBatchInfo. Represents the property batch failing. Contains information about the specific batch failure.",
      "allOf": [
        {
          "$ref": "#/definitions/PropertyBatchInfo"
        },
        {
          "type": "object",
          "description": "FailedPropertyBatchInfo"
        }
      ],
      "x-ms-discriminator-value": "Failed",
      "properties": {
        "ErrorMessage": {
          "type": "string",
          "description": "The error message of the failed operation. Describes the exception thrown due to the first unsuccessful operation in the property batch."
        },
        "OperationIndex": {
          "type": "integer",
          "description": "The index of the unsuccessful operation in the property batch."
        }
      }
    },
    "EntityKind": {
      "type": "string",
      "description": "The entity type of a Service Fabric entity such as Cluster, Node, Application, Service, Partition, Replica etc.\n\n  - Invalid - Indicates an invalid entity kind. All Service Fabric enumerations have the invalid type. The value is zero.\n  - Node - Indicates the entity is a Service Fabric node. The value is 1.\n  - Partition - Indicates the entity is a Service Fabric partition. The value is 2.\n  - Service - Indicates the entity is a Service Fabric service. The value is 3.\n  - Application - Indicates the entity is a Service Fabric application. The value is 4.\n  - Replica - Indicates the entity is a Service Fabric replica. The value is 5.\n  - DeployedApplication - Indicates the entity is a Service Fabric deployed application. The value is 6.\n  - DeployedServicePackage - Indicates the entity is a Service Fabric deployed service package. The value is 7.\n  - Cluster - Indicates the entity is a Service Fabric cluster. The value is 8.\n",
      "enum": [
        "Invalid",
        "Node",
        "Partition",
        "Service",
        "Application",
        "Replica",
        "DeployedApplication",
        "DeployedServicePackage",
        "Cluster"
      ]
    },
    "HealthStateCount": {
      "type": "object",
      "description": "Represents information about how many health entities are in Ok, Warning and Error health state.\n",
      "properties": {
        "OkCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of health entities with aggregated health state Ok.",
          "minimum": 0
        },
        "WarningCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of health entities with aggregated health state Warning.",
          "minimum": 0
        },
        "ErrorCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of health entities with aggregated health state Error.",
          "minimum": 0
        }
      }
    },
    "EntityKindHealthStateCount": {
      "type": "object",
      "description": "Represents health state count for entities of the specified entity kind.",
      "properties": {
        "EntityKind": {
          "$ref": "#/definitions/EntityKind"
        },
        "HealthStateCount": {
          "$ref": "#/definitions/HealthStateCount"
        }
      }
    },
    "HealthStatistics": {
      "type": "object",
      "description": "The health statistics of an entity, returned as part of the health query result when the query description is configured to include statistics.\nThe statistics include health state counts for all children types of the current entity.\nFor example, for cluster, the health statistics include health state counts for nodes, applications, services, partitions, replicas, deployed applications and deployed service packages.\nFor partition, the health statistics include health counts for replicas.\n",
      "properties": {
        "HealthStateCountList": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EntityKindHealthStateCount"
          },
          "description": "List of health state counts per entity kind, which keeps track of how many children of the queried entity are in Ok, Warning and Error state.\n"
        }
      }
    },
    "NodeImpact": {
      "type": "object",
      "description": "Describes the expected impact of a repair to a particular node.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "NodeName": {
          "type": "string",
          "description": "The name of the impacted node."
        },
        "ImpactLevel": {
          "type": "string",
          "enum": [
            "Invalid",
            "None",
            "Restart",
            "RemoveData",
            "RemoveNode"
          ],
          "description": "The level of impact expected."
        }
      },
      "required": [
        "NodeName"
      ]
    },
    "NodeRepairImpactDescription": {
      "description": "Describes the expected impact of a repair on a set of nodes.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "x-ms-discriminator-value": "Node",
      "allOf": [
        {
          "$ref": "#/definitions/RepairImpactDescriptionBase"
        },
        {
          "type": "object",
          "description": "NodeRepairImpactDescription",
          "properties": {
            "NodeImpactList": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/NodeImpact"
              },
              "description": "The list of nodes impacted by a repair action and their respective expected impact."
            }
          }
        }
      ]
    },
    "NodeRepairTargetDescription": {
      "description": "Describes the list of nodes targeted by a repair action.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "x-ms-discriminator-value": "Node",
      "allOf": [
        {
          "$ref": "#/definitions/RepairTargetDescriptionBase"
        },
        {
          "type": "object",
          "description": "NodeRepairTargetDescription",
          "properties": {
            "NodeNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The list of nodes targeted by a repair action."
            }
          }
        }
      ]
    },
    "RepairImpactDescriptionBase": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Describes the expected impact of executing a repair task.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/RepairImpactKind"
        }
      },
      "required": [
        "Kind"
      ]
    },
    "RepairImpactKind": {
      "description": "Specifies the kind of the impact.\n- Invalid - The repair impact is not valid or is of an unknown type.\n- Node - The repair impact affects a set of Service Fabric nodes.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "type": "string",
      "enum": [
        "Invalid",
        "Node"
      ]
    },
    "RepairTargetDescriptionBase": {
      "type": "object",
      "discriminator": "Kind",
      "description": "Describes the entities targeted by a repair action.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "Kind": {
          "$ref": "#/definitions/RepairTargetKind"
        }
      },
      "required": [
        "Kind"
      ]
    },
    "RepairTargetKind": {
      "description": "Specifies the kind of the repair target.\n- Invalid - The repair target is not valid or is of an unknown type.\n- Node - The repair target is a set of Service Fabric nodes.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "type": "string",
      "enum": [
        "Invalid",
        "Node"
      ]
    },
    "RepairTask": {
      "type": "object",
      "description": "Represents a repair task, which includes information about what kind of repair was requested, what its progress is, and what its final result was.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "TaskId": {
          "type": "string",
          "description": "The ID of the repair task."
        },
        "Version": {
          "type": "string",
          "format": "int64",
          "description": "The version of the repair task.\nWhen creating a new repair task, the version must be set to zero.  When updating a repair task, \nthe version is used for optimistic concurrency checks.  If the version is \nset to zero, the update will not check for write conflicts.  If the version is set to a non-zero value, then the \nupdate will only succeed if the actual current version of the repair task matches this value.\n"
        },
        "Description": {
          "type": "string",
          "description": "A description of the purpose of the repair task, or other informational details.\nMay be set when the repair task is created, and is immutable once set.\n"
        },
        "State": {
          "type": "string",
          "enum": [
            "Invalid",
            "Created",
            "Claimed",
            "Preparing",
            "Approved",
            "Executing",
            "Restoring",
            "Completed"
          ],
          "description": "The workflow state of the repair task. Valid initial states are Created, Claimed, and Preparing.\n\n- Invalid - Indicates that the repair task state is invalid. All Service Fabric enumerations have the invalid value.\n- Created - Indicates that the repair task has been created.\n- Claimed - Indicates that the repair task has been claimed by a repair executor.\n- Preparing - Indicates that the Repair Manager is preparing the system to handle the impact of the repair task, usually by taking resources offline gracefully.\n- Approved - Indicates that the repair task has been approved by the Repair Manager and is safe to execute.\n- Executing - Indicates that execution of the repair task is in progress.\n- Restoring - Indicates that the Repair Manager is restoring the system to its pre-repair state, usually by bringing resources back online.\n- Completed - Indicates that the repair task has completed, and no further state changes will occur.\n"
        },
        "Flags": {
          "type": "integer",
          "description": "A bitwise-OR of the following values, which gives additional details about the status of the repair task.\n- 1 - Cancellation of the repair has been requested\n- 2 - Abort of the repair has been requested\n- 4 - Approval of the repair was forced via client request\n"
        },
        "Action": {
          "type": "string",
          "description": "The requested repair action. Must be specified when the repair task is created, and is immutable once set.\n"
        },
        "Target": {
          "$ref": "#/definitions/RepairTargetDescriptionBase"
        },
        "Executor": {
          "type": "string",
          "description": "The name of the repair executor. Must be specified in Claimed and later states, and is immutable once set."
        },
        "ExecutorData": {
          "type": "string",
          "description": "A data string that the repair executor can use to store its internal state."
        },
        "Impact": {
          "$ref": "#/definitions/RepairImpactDescriptionBase"
        },
        "ResultStatus": {
          "type": "string",
          "enum": [
            "Invalid",
            "Succeeded",
            "Cancelled",
            "Interrupted",
            "Failed",
            "Pending"
          ],
          "description": "A value describing the overall result of the repair task execution.\nMust be specified in the Restoring and later states, and is immutable once set.\n\n- Invalid - Indicates that the repair task result is invalid. All Service Fabric enumerations have the invalid value.\n- Succeeded - Indicates that the repair task completed execution successfully.\n- Cancelled - Indicates that the repair task was cancelled prior to execution.\n- Interrupted - Indicates that execution of the repair task was interrupted by a cancellation request after some work had already been performed.\n- Failed - Indicates that there was a failure during execution of the repair task. Some work may have been performed.\n- Pending - Indicates that the repair task result is not yet available, because the repair task has not finished executing.\n"
        },
        "ResultCode": {
          "type": "integer",
          "description": "A numeric value providing additional details about the result of the repair task execution.\nMay be specified in the Restoring and later states, and is immutable once set.\n"
        },
        "ResultDetails": {
          "type": "string",
          "description": "A string providing additional details about the result of the repair task execution.\nMay be specified in the Restoring and later states, and is immutable once set.\n"
        },
        "History": {
          "$ref": "#/definitions/RepairTaskHistory"
        },
        "PreparingHealthCheckState": {
          "$ref": "#/definitions/RepairTaskHealthCheckState"
        },
        "RestoringHealthCheckState": {
          "$ref": "#/definitions/RepairTaskHealthCheckState"
        },
        "PerformPreparingHealthCheck": {
          "type": "boolean",
          "description": "A value to determine if health checks will be performed when the repair task enters the Preparing state."
        },
        "PerformRestoringHealthCheck": {
          "type": "boolean",
          "description": "A value to determine if health checks will be performed when the repair task enters the Restoring state."
        }
      },
      "required": [
        "TaskId",
        "Action",
        "State"
      ]
    },
    "RepairTaskApproveDescription": {
      "type": "object",
      "description": "Describes a request for forced approval of a repair task.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "TaskId": {
          "type": "string",
          "description": "The ID of the repair task."
        },
        "Version": {
          "type": "string",
          "format": "int64",
          "description": "The current version number of the repair task. If non-zero, then the request will only succeed if this value matches the actual current version of the repair task. If zero, then no version check is performed.</para>"
        }
      },
      "required": [
        "TaskId"
      ]
    },
    "RepairTaskCancelDescription": {
      "type": "object",
      "description": "Describes a request to cancel a repair task.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "TaskId": {
          "type": "string",
          "description": "The ID of the repair task."
        },
        "Version": {
          "type": "string",
          "format": "int64",
          "description": "The current version number of the repair task. If non-zero, then the request will only succeed if this value matches the actual current version of the repair task. If zero, then no version check is performed.</para>"
        },
        "RequestAbort": {
          "type": "boolean",
          "description": "_True_ if the repair should be stopped as soon as possible even if it has already started executing. _False_ if the repair should be cancelled only if execution has not yet started.</para>"
        }
      },
      "required": [
        "TaskId"
      ]
    },
    "RepairTaskDeleteDescription": {
      "type": "object",
      "description": "Describes a request to delete a completed repair task.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "TaskId": {
          "type": "string",
          "description": "The ID of the completed repair task to be deleted."
        },
        "Version": {
          "type": "string",
          "format": "int64",
          "description": "The current version number of the repair task. If non-zero, then the request will only succeed if this value matches the actual current version of the repair task. If zero, then no version check is performed."
        }
      },
      "required": [
        "TaskId"
      ]
    },
    "RepairTaskHealthCheckState": {
      "description": "Specifies the workflow state of a repair task's health check.\n\n- NotStarted - Indicates that the health check has not started.\n- InProgress - Indicates that the health check is in progress.\n- Succeeded - Indicates that the health check succeeded.\n- Skipped - Indicates that the health check was skipped.\n- TimedOut - Indicates that the health check timed out.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "type": "string",
      "enum": [
        "NotStarted",
        "InProgress",
        "Succeeded",
        "Skipped",
        "TimedOut"
      ]
    },
    "RepairTaskHistory": {
      "type": "object",
      "description": "A record of the times when the repair task entered each state.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "CreatedUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Created state."
        },
        "ClaimedUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Claimed state."
        },
        "PreparingUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Preparing state."
        },
        "ApprovedUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Approved state"
        },
        "ExecutingUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Executing state"
        },
        "RestoringUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Restoring state"
        },
        "CompletedUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task entered the Completed state"
        },
        "PreparingHealthCheckStartUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task started the health check in the Preparing state."
        },
        "PreparingHealthCheckEndUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task completed the health check in the Preparing state."
        },
        "RestoringHealthCheckStartUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task started the health check in the Restoring state."
        },
        "RestoringHealthCheckEndUtcTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the repair task completed the health check in the Restoring state."
        }
      }
    },
    "RepairTaskList": {
      "type": "array",
      "description": "A list of repair tasks.",
      "items": {
        "$ref": "#/definitions/RepairTask"
      }
    },
    "RepairTaskUpdateHealthPolicyDescription": {
      "type": "object",
      "description": "Describes a request to update the health policy of a repair task.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "TaskId": {
          "type": "string",
          "description": "The ID of the repair task to be updated."
        },
        "Version": {
          "type": "string",
          "format": "int64",
          "description": "The current version number of the repair task. If non-zero, then the request will only succeed if this value matches the actual current value of the repair task. If zero, then no version check is performed."
        },
        "PerformPreparingHealthCheck": {
          "type": "boolean",
          "description": "A boolean indicating if health check is to be performed in the Preparing stage of the repair task. If not specified the existing value should not be altered. Otherwise, specify the desired new value."
        },
        "PerformRestoringHealthCheck": {
          "type": "boolean",
          "description": "A boolean indicating if health check is to be performed in the Restoring stage of the repair task. If not specified the existing value should not be altered. Otherwise, specify the desired new value."
        }
      },
      "required": [
        "TaskId"
      ]
    },
    "RepairTaskUpdateInfo": {
      "type": "object",
      "description": "Describes the result of an operation that created or updated a repair task.\n\nThis type supports the Service Fabric platform; it is not meant to be used directly from your code.\n",
      "properties": {
        "Version": {
          "type": "string",
          "format": "int64",
          "description": "The new version of the repair task."
        }
      },
      "required": [
        "Version"
      ]
    },
    "ReconfigurationInformation": {
      "description": "Information about current reconfiguration like phase, type, previous configuration role of replica and reconfiguration start date time.",
      "properties": {
        "PreviousConfigurationRole": {
          "$ref": "#/definitions/ReplicaRole"
        },
        "ReconfigurationPhase": {
          "$ref": "#/definitions/ReconfigurationPhase"
        },
        "ReconfigurationType": {
          "$ref": "#/definitions/ReconfigurationType"
        },
        "ReconfigurationStartTimeUtc": {
          "type": "string",
          "format": "date-time",
          "description": "Start time (in UTC) of the ongoing reconfiguration. If no reconfiguration is taking place then this value will be zero date-time."
        }
      }
    },
    "ReconfigurationPhase": {
      "type": "string",
      "description": "The reconfiguration phase of a replica of a stateful service. Possible values are following.\n  - Unknown - Indicates the invalid reconfiguration phase.\n  - None - Specifies that there is no reconfiguration in progress.\n  - Phase0 - Refers to the phase where the reconfiguration is transferring data from the previous primary to the new primary.\n  - Phase1 - Refers to the phase where the reconfiguration is querying the replica set for the progress.\n  - Phase2 - Refers to the phase where the reconfiguration is ensuring that data from the current primary is present in a majority of the replica set.\n  - Phase3 - This phase is for internal use only.\n  - Phase4 - This phase is for internal use only.\n  - AbortPhaseZero - This phase is for internal use only.\n",
      "enum": [
        "Unknown",
        "None",
        "Phase0",
        "Phase1",
        "Phase2",
        "Phase3",
        "Phase4",
        "AbortPhaseZero"
      ]
    },
    "ReconfigurationType": {
      "type": "string",
      "description": "The type of reconfiguration for replica of a stateful service. Possible values are following.\n  - Unknown - Indicates the invalid reconfiguration type.\n  - SwapPrimary - Specifies that the primary replica is being swapped with a different replica.\n  - Failover - Reconfiguration triggered in response to a primary going down. This could be due to many reasons such as primary replica crashing etc.\n  - Other - Reconfigurations where the primary replica is not changing.\n",
      "enum": [
        "Unknown",
        "SwapPrimary",
        "Failover",
        "Other"
      ]
    },
    "InfrastructureServiceResponse": {
      "type": "string",
      "format": "binary",
      "description": "This is a weakly-typed response stream to the client. It contains the JSON response from the infrastructure service without deserialization.\nThe content of the response depends on which command was issued to the infrastructure service.\n"
    }
  },
  "parameters": {
    "ApiVersionRequiredQueryParam": {
      "name": "api-version",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "6.0"
      ],
      "required": true,
      "default": "6.0",
      "description": "The version of the API. This is a required parameter and it's value must be \"6.0\"."
    },
    "ApiVersion_6-0-Preview_RequiredQueryParam": {
      "name": "api-version",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "6.0-preview"
      ],
      "required": true,
      "default": "6.0-preview",
      "description": "The version of the API. This is a required parameter and its value must be \"6.0-preview\"."
    },
    "ApplicationDefinitionKindFilterOptionalQueryParam": {
      "name": "ApplicationDefinitionKindFilter",
      "description": "Used to filter on ApplicationDefinitionKind for application query operations.\n- Default - Default value, which performs the same function as selecting \"All\". The value is 0.\n- All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.\n- ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.\n- Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "ApplicationHealthPolicyOptionalBodyParam": {
      "name": "ApplicationHealthPolicy",
      "in": "body",
      "description": "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy.\n",
      "required": false,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ApplicationHealthPolicy"
      }
    },
    "ApplicationIdRequiredPathParam": {
      "name": "applicationId",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the \"~\" character. For example, if the application name is \"fabric://myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."
    },
    "ApplicationsHealthStateFilterOptionalQueryParam": {
      "name": "ApplicationsHealthStateFilter",
      "description": "Allows filtering of the application health state objects returned in the result of cluster health\nquery based on their health state.\nThe possible values for this parameter include integer value obtained from members or bitwise operations\non members of HealthStateFilter enumeration. Only applications that match the filter are returned.\nAll applications are used to evaluate the aggregated health state. If not specified, all entries are returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "ApplicationTypeDefinitionKindFilterOptionalQueryParam": {
      "name": "ApplicationTypeDefinitionKindFilter",
      "description": "Used to filter on ApplicationTypeDefinitionKind for application type query operations.\n- Default - Default value, which performs the same function as selecting \"All\". The value is 0.\n- All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.\n- ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.\n- Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "ApplicationTypeNameOptionalQueryParam": {
      "name": "ApplicationTypeName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The application type name used to filter the applications to query for. This value should not contain the application type version."
    },
    "ApplicationTypeNameRequiredPathParam": {
      "name": "applicationTypeName",
      "in": "path",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The name of the application type."
    },
    "ApplicationTypeVersionOptionalQueryParam": {
      "name": "ApplicationTypeVersion",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The version of the application type."
    },
    "ApplicationTypeVersionRequiredQueryParam": {
      "name": "ApplicationTypeVersion",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The version of the application type."
    },
    "ClusterConfigurationUpgradeDescriptionRequiredBodyParam": {
      "name": "ClusterConfigurationUpgradeDescription",
      "in": "body",
      "description": "Parameters for a standalone cluster configuration upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ClusterConfigurationUpgradeDescription"
      }
    },
    "ClusterHealthPoliciesOptionalBodyParam": {
      "name": "ClusterHealthPolicies",
      "in": "body",
      "description": "Describes the health policies used to evaluate the cluster health.\nIf not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.\nBy default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.\nIf the application health policy map is specified, and it has an entry for an application, the specified application health policy\nis used to evaluate the application health.\n",
      "required": false,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ClusterHealthPolicies"
      }
    },
    "ClusterHealthPolicyOptionalBodyParam": {
      "name": "ClusterHealthPolicy",
      "in": "body",
      "description": "Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.",
      "required": false,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ClusterHealthPolicy"
      }
    },
    "ClusterHealthChunkQueryDescriptionOptionalBodyParam": {
      "name": "ClusterHealthChunkQueryDescription",
      "in": "body",
      "description": "Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.\nIf the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.\nBy default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.\nIf the application health policy map is specified, and it has an entry for an application, the specified application health policy\nis used to evaluate the application health.\nUsers can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.\nThe query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return\nonly services that are in Error or Warning, and all partitions and replicas for one of these services.\n",
      "required": false,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ClusterHealthChunkQueryDescription"
      }
    },
    "CodeVersionOptionalQueryParam": {
      "name": "CodeVersion",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The product version of Service Fabric."
    },
    "ConfigVersionOptionalQueryParam": {
      "name": "ConfigVersion",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The config version of Service Fabric."
    },
    "ConfigurationApiVersionRequiredQueryParam": {
      "name": "ConfigurationApiVersion",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The API version of the Standalone cluster json configuration."
    },
    "ContinuationTokenOptionalQueryParam": {
      "name": "ContinuationToken",
      "in": "query",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": false,
      "description": "The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded."
    },
    "DeployedApplicationsHealthStateFilterOptionalQueryParam": {
      "name": "DeployedApplicationsHealthStateFilter",
      "description": "Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\\\nAll deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.\nThe state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "DeployedServicePackagesHealthStateFilterOptionalQueryParam": {
      "name": "DeployedServicePackagesHealthStateFilter",
      "description": "Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.\nIf not specified, all entries are returned.\nThe state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "DeploymentNameRequiredPathParam": {
      "name": "deploymentName",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "The identity of the deployment."
    },
    "EventsHealthStateFilterOptionalQueryParam": {
      "name": "EventsHealthStateFilter",
      "description": "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "ExcludeApplicationParametersOptionalQueryParam": {
      "name": "ExcludeApplicationParameters",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "default": false,
      "description": "The flag that specifies whether application parameters will be excluded from the result."
    },
    "HealthInformationRequiredBodyParam": {
      "name": "HealthInformation",
      "in": "body",
      "description": "Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/HealthInformation"
      }
    },
    "NodeNameRequiredPathParam": {
      "name": "nodeName",
      "in": "path",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The name of the node."
    },
    "NodesHealthStateFilterOptionalQueryParam": {
      "name": "NodesHealthStateFilter",
      "description": "Allows filtering of the node health state objects returned in the result of cluster health query\nbased on their health state. The possible values for this parameter include integer value of one of the\nfollowing health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.\nIf not specified, all entries are returned.\nThe state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "NodeStatusFilterOptionalQueryParam": {
      "name": "NodeStatusFilter",
      "description": "Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.\n\n  - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.\n  - all - This filter value will match all of the nodes.\n  - up - This filter value will match nodes that are Up.\n  - down - This filter value will match nodes that are Down.\n  - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.\n  - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.\n  - disabled - This filter value will match nodes that are Disabled.\n  - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.\n  - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "default",
        "all",
        "up",
        "down",
        "enabling",
        "disabling",
        "disabled",
        "unknown",
        "removed"
      ],
      "required": false,
      "default": "default"
    },
    "PartitionIdOptionalQueryParam": {
      "name": "PartitionId",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "format": "uuid",
      "required": false,
      "description": "The identity of the partition."
    },
    "PartitionIdRequiredPathParam": {
      "name": "partitionId",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "format": "uuid",
      "required": true,
      "description": "The identity of the partition."
    },
    "ProvisionFabricDescriptionRequiredBodyParam": {
      "name": "ProvisionFabricDescription",
      "in": "body",
      "description": "Describes the parameters for provisioning a cluster.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ProvisionFabricDescription"
      }
    },
    "UnprovisionFabricDescriptionRequiredBodyParam": {
      "name": "UnprovisionFabricDescription",
      "in": "body",
      "description": "Describes the parameters for unprovisioning a cluster.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/UnprovisionFabricDescription"
      }
    },
    "ResumeClusterUpgradeDescriptionRequiredBodyParam": {
      "name": "ResumeClusterUpgradeDescription",
      "in": "body",
      "description": "Describes the parameters for resuming a cluster upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ResumeClusterUpgradeDescription"
      }
    },
    "UpdateClusterUpgradeDescriptionRequiredBodyParam": {
      "name": "UpdateClusterUpgradeDescription",
      "in": "body",
      "description": "Parameters for updating a cluster upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/UpdateClusterUpgradeDescription"
      }
    },
    "StartClusterUpgradeDescriptionRequiredBodyParam": {
      "name": "StartClusterUpgradeDescription",
      "in": "body",
      "description": "Describes the parameters for starting a cluster upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/StartClusterUpgradeDescription"
      }
    },
    "ReplicaHealthReportServiceKindRequiredQueryParam": {
      "name": "ServiceKind",
      "in": "query",
      "required": true,
      "x-ms-parameter-location": "method",
      "description": "The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.\n- Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1\n- Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.\n",
      "type": "string",
      "enum": [
        "Stateless",
        "Stateful"
      ],
      "default": "Stateful"
    },
    "ReplicaIdRequiredPathParam": {
      "name": "replicaId",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "The identifier of the replica."
    },
    "ReplicasHealthStateFilerOptionalQueryParam": {
      "name": "ReplicasHealthStateFilter",
      "description": "Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "ServiceIdRequiredPathParam": {
      "name": "serviceId",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the \"~\" character. For example, if the service name is \"fabric://myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."
    },
    "ServiceManifestNameOptionalQueryParam": {
      "name": "ServiceManifestName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The name of a service manifest registered as part of an application type in a Service Fabric cluster."
    },
    "ServiceManifestNameRequiredQueryParam": {
      "name": "ServiceManifestName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The name of a service manifest registered as part of an application type in a Service Fabric cluster."
    },
    "ServicePackageNameRequiredPathParam": {
      "name": "servicePackageName",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "The name of the service package."
    },
    "ServicesHealthStateFilterOptionalQueryParam": {
      "name": "ServicesHealthStateFilter",
      "description": "Allows filtering of the services health state objects returned in the result of services health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly services that match the filter are returned. All services are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value\nobtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "CreateServiceFromTemplateRequiredBodyParam": {
      "name": "ServiceFromTemplateDescription",
      "in": "body",
      "description": "Describes the service that needs to be created from the template defined in the application manifest.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ServiceFromTemplateDescription"
      }
    },
    "ServiceTypeNameOptionalQueryParam": {
      "name": "ServiceTypeName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The service type name used to filter the services to query for."
    },
    "InfrastructureCommandRequiredQueryParam": {
      "name": "Command",
      "description": "The text of the command to be invoked. The content of the command is infrastructure-specific.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true
    },
    "InfrastructureServiceIdOptionalQueryParam": {
      "name": "ServiceId",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "description": "The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.",
      "required": false
    },
    "ForceRemoveOptionalQueryParam": {
      "name": "ForceRemove",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "description": "Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas."
    },
    "ForceRemoveReplicaOptionalQueryParam": {
      "name": "ForceRemove",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "description": "Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas."
    },
    "DeactivationIntentDescriptionRequiredBodyParam": {
      "name": "DeactivationIntentDescription",
      "in": "body",
      "description": "Describes the intent or reason for deactivating the node.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/DeactivationIntentDescription"
      }
    },
    "RestartNodeDescriptionRequiredBodyParam": {
      "name": "RestartNodeDescription",
      "in": "body",
      "description": "The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/RestartNodeDescription"
      }
    },
    "ApplicationUpgradeDescriptionRequiredBodyParam": {
      "name": "ApplicationUpgradeDescription",
      "in": "body",
      "description": "Parameters for an application upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ApplicationUpgradeDescription"
      }
    },
    "ComposeDeploymentUpgradeDescriptionRequiredBodyParam": {
      "name": "ComposeDeploymentUpgradeDescription",
      "in": "body",
      "description": "Parameters for upgrading compose deployment.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ComposeDeploymentUpgradeDescription"
      }
    },
    "ApplicationTypeImageStorePathRequiredBodyParam": {
      "name": "ApplicationTypeImageStorePath",
      "in": "body",
      "description": "The relative path for the application package in the image store specified during the prior copy operation.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ApplicationTypeImageStorePath"
      }
    },
    "ApplicationTypeVersionRequiredBodyParam": {
      "name": "ApplicationTypeImageStoreVersion",
      "in": "body",
      "description": "The version of the application type in the image store.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ApplicationTypeImageStoreVersion"
      }
    },
    "ChaosParametersRequiredBodyParam": {
      "name": "ChaosParameters",
      "in": "body",
      "description": "Describes all the parameters to configure a Chaos run.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ChaosParameters"
      }
    },
    "StartTimeUtcOptionalQueryParam": {
      "name": "StartTimeUtc",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick."
    },
    "EndTimeUtcOptionalQueryParam": {
      "name": "EndTimeUtc",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick."
    },
    "ApplicationNameRequiredQueryParam": {
      "name": "ApplicationName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The name of application to create from compose file. This is typically the full name of the application including 'fabric:' URI scheme."
    },
    "CreateComposeDeploymentRequiredBodyParam": {
      "name": "CreateComposeDeploymentDescription",
      "in": "body",
      "description": "Describes the compose deployment that needs to be created.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/CreateComposeDeploymentDescription"
      }
    },
    "PasswordEncryptedOptionalQueryParam": {
      "name": "PasswordEncrypted",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "description": "Indicates that supplied container repository password is encrypted."
    },
    "RepositoryPasswordOptionalQueryParam": {
      "name": "RepositoryPassword",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The password for supplied username to connect to container repository."
    },
    "RepositoryUserNameOptionalQueryParam": {
      "name": "RepositoryUserName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The user name to connect to container repository."
    },
    "MaxResultsOptionalQueryParam": {
      "name": "MaxResults",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "format": "int64",
      "minimum": 0,
      "default": 0,
      "required": false,
      "description": "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message."
    },
    "ApplicationDescriptionRequiredBodyParam": {
      "name": "ApplicationDescription",
      "in": "body",
      "description": "Description for creating an application.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ApplicationDescription"
      }
    },
    "ServiceDescriptionRequiredBodyParam": {
      "name": "ServiceDescription",
      "in": "body",
      "description": "The information necessary to create a service.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ServiceDescription"
      }
    },
    "ServiceUpdateDescriptionRequiredBodyParam": {
      "name": "ServiceUpdateDescription",
      "in": "body",
      "description": "The information necessary to update a service.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ServiceUpdateDescription"
      }
    },
    "ImageStoreCopyDescriptionRequiredBodyParam": {
      "name": "ImageStoreCopyDescription",
      "in": "body",
      "description": "Describes the copy description for the image store.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ImageStoreCopyDescription"
      }
    },
    "CodePackageNameOptionalQueryParam": {
      "name": "CodePackageName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster."
    },
    "RestartDeployedCodePackageRequiredBodyParam": {
      "name": "RestartDeployedCodePackageDescription",
      "in": "body",
      "description": "Describes the deployed code package on Service Fabric node to restart.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/RestartDeployedCodePackageDescription"
      }
    },
    "PartitionsHealthStateFilterOptionalQueryParam": {
      "name": "PartitionsHealthStateFilter",
      "description": "Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value\nobtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false,
      "default": 0
    },
    "DeployedServiceType_ServiceManifestNameOptionalQueryParam": {
      "name": "ServiceManifestName",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false,
      "description": "The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest."
    },
    "ServiceTypeNameRequiredPathParam": {
      "name": "serviceTypeName",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "Specifies the name of a Service Fabric service type."
    },
    "ImageStoreContentPathRequiredPathParam": {
      "name": "contentPath",
      "in": "path",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "Relative path to file or folder in the image store from its root."
    },
    "PartitionKeyTypeOptionalQueryParam": {
      "name": "PartitionKeyType",
      "description": "Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.\n- None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.\n- Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.\n- Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false
    },
    "PartitionKeyValueOptionalQueryParam": {
      "name": "PartitionKeyValue",
      "in": "query",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": false,
      "description": "Partition key. This is required if the partition scheme for the service is Int64Range or Named."
    },
    "PreviousRspVersionOptionalQueryParam": {
      "name": "PreviousRspVersion",
      "in": "query",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": false,
      "description": "The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale."
    },
    "DataLossModeRequiredQueryParam": {
      "name": "DataLossMode",
      "description": "This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.\n- Invalid - Reserved.  Do not pass into API.\n- PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.\n- FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "Invalid",
        "PartialDataLoss",
        "FullDataLoss"
      ],
      "required": true
    },
    "FaultOperationIdRequiredQueryParam": {
      "name": "OperationId",
      "description": "A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "format": "uuid",
      "required": true
    },
    "ForceRequiredQueryParam": {
      "name": "Force",
      "description": "Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": true,
      "default": false
    },
    "NodeInstanceIdRequiredQueryParam": {
      "name": "NodeInstanceId",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true,
      "description": "The node instance ID of the target node.  This can be determined through GetNodeInfo API."
    },
    "NodeTransitionTypeRequiredQueryParam": {
      "name": "NodeTransitionType",
      "description": "Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.\n  - Invalid - Reserved.  Do not pass into API.\n  - Start - Transition a stopped node to up.\n  - Stop - Transition an up node to stopped.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "Invalid",
        "Start",
        "Stop"
      ],
      "required": true
    },
    "QuorumLossDurationRequiredQueryParam": {
      "name": "QuorumLossDuration",
      "description": "The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": true
    },
    "QuorumLossModeRequiredQueryParam": {
      "name": "QuorumLossMode",
      "description": "This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.\n  - Invalid - Reserved.  Do not pass into API.\n  - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.\n  - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "Invalid",
        "QuorumReplicas",
        "AllReplicas"
      ],
      "required": true
    },
    "RestartPartitionModeRequiredQueryParam": {
      "name": "RestartPartitionMode",
      "description": "- Invalid - Reserved.  Do not pass into API.\n- AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.\n- OnlyActiveSecondaries - Only the secondary replicas are restarted.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "enum": [
        "Invalid",
        "AllReplicasOrInstances",
        "OnlyActiveSecondaries"
      ],
      "required": true
    },
    "StateFilterRequiredQueryParam": {
      "name": "StateFilter",
      "description": "Used to filter on OperationState's for user-induced operations.\n65535 - select All\n1     - select Running\n2     - select RollingBack\n8     - select Completed\n16    - select Faulted\n32    - select Cancelled\n64    - select ForceCancelled\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": true,
      "default": 65535
    },
    "StopDurationInSecondsRequiredQueryParam": {
      "name": "StopDurationInSeconds",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "format": "int32",
      "minimum": 0,
      "required": true,
      "description": "The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up."
    },
    "TypeFilterRequiredQueryParam": {
      "name": "TypeFilter",
      "description": "Used to filter on OperationType for user-induced operations.\n65535 - select all\n1     - select PartitionDataLoss.\n2     - select PartitionQuorumLoss.\n4     - select PartitionRestart.\n8     - select NodeTransition.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": true,
      "default": 65535
    },
    "DeployServicePackageToNodeRequiredBodyParam": {
      "name": "DeployServicePackageToNodeDescription",
      "in": "body",
      "description": "Describes information for deploying a service package to a Service Fabric node.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/DeployServicePackageToNodeDescription"
      }
    },
    "ResumeApplicationUpgradeDescriptionRequiredBodyParam": {
      "name": "ResumeApplicationUpgradeDescription",
      "in": "body",
      "description": "Describes the parameters for resuming an application upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ResumeApplicationUpgradeDescription"
      }
    },
    "ApplicationUpgradeUpdateDescriptionRequiredBodyParam": {
      "name": "ApplicationUpgradeUpdateDescription",
      "in": "body",
      "description": "Parameters for updating an existing application upgrade.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/ApplicationUpgradeUpdateDescription"
      }
    },
    "TimeoutOptionalQueryParam": {
      "name": "timeout",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "format": "int64",
      "required": false,
      "minimum": 1,
      "maximum": 4294967295,
      "default": 60,
      "description": "The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."
    },
    "NameDescriptionRequiredBodyParam": {
      "name": "NameDescription",
      "in": "body",
      "description": "Describes the Service Fabric name to be created.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/NameDescription"
      }
    },
    "NameIdRequiredPathParam": {
      "name": "nameId",
      "in": "path",
      "x-ms-parameter-location": "method",
      "x-ms-skip-url-encoding": true,
      "type": "string",
      "required": true,
      "description": "The Service Fabric name, without the 'fabric:' URI scheme."
    },
    "RecursiveOptionalQueryParam": {
      "name": "Recursive",
      "description": "Allows specifying that the search performed should be recursive.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "default": false
    },
    "IncludeValuesOptionalQueryParam": {
      "name": "IncludeValues",
      "description": "Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "default": false
    },
    "PropertyDescriptionRequiredBodyParam": {
      "name": "PropertyDescription",
      "in": "body",
      "description": "Describes the Service Fabric property to be created.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/PropertyDescription"
      }
    },
    "PropertyNameRequiredQueryParam": {
      "name": "PropertyName",
      "description": "Specifies the name of the property to get.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": true
    },
    "PropertyBatchDescriptionListRequiredBodyParam": {
      "name": "PropertyBatchDescriptionList",
      "in": "body",
      "description": "Describes the property batch operations to be submitted.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/PropertyBatchDescriptionList"
      }
    },
    "ImmediateOptionalQueryParam": {
      "name": "Immediate",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "default": false,
      "description": "A flag which indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately.\n"
    },
    "ExcludeHealthStatisticsOptionalQueryParam": {
      "name": "ExcludeHealthStatistics",
      "description": "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "default": false
    },
    "IncludeSystemApplicationHealthStatisticsOptionalQueryParam": {
      "name": "IncludeSystemApplicationHealthStatistics",
      "description": "Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.\nIf IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.\nOtherwise, the query result includes health statistics only for user applications.\nThe health statistics must be included in the query result for this parameter to be applied.\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "boolean",
      "required": false,
      "default": false
    },
    "RepairTaskApproveDescriptionRequiredBodyParam": {
      "name": "RepairTaskApproveDescription",
      "in": "body",
      "description": "Describes the repair task to be approved.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/RepairTaskApproveDescription"
      }
    },
    "RepairTaskCancelDescriptionRequiredBodyParam": {
      "name": "RepairTaskCancelDescription",
      "in": "body",
      "description": "Describes the repair task to be cancelled.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/RepairTaskCancelDescription"
      }
    },
    "RepairTaskDeleteDescriptionRequiredBodyParam": {
      "name": "RepairTaskDeleteDescription",
      "in": "body",
      "description": "Describes the repair task to be deleted.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/RepairTaskDeleteDescription"
      }
    },
    "RepairTaskExecutorFilterOptionalQueryParam": {
      "name": "ExecutorFilter",
      "description": "The name of the repair executor whose claimed tasks should be included in the list.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false
    },
    "RepairTaskIdFilterOptionalQueryParam": {
      "name": "TaskIdFilter",
      "description": "The repair task ID prefix to be matched.",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "string",
      "required": false
    },
    "RepairTaskRequiredBodyParam": {
      "name": "RepairTask",
      "in": "body",
      "description": "Describes the repair task to be created or updated.",
      "required": true,
      "x-ms-parameter-location": "method",
      "schema": {
        "$ref": "#/definitions/RepairTask"
      }
    },
    "RepairTaskStateFilterOptionalQueryParam": {
      "name": "StateFilter",
      "description": "A bitwise-OR of the following values, specifying which task states should be included in the result list.\n- 1 - Created\n- 2 - Claimed\n- 4 - Preparing\n- 8 - Approved\n- 16 - Executing\n- 32 - Restoring\n- 64 - Completed\n",
      "in": "query",
      "x-ms-parameter-location": "method",
      "type": "integer",
      "required": false
    },
    "RepairTaskUpdateHealthPolicyDescriptionRequiredBodyParam": {
      "name": "RepairTaskUpdateHealthPolicyDescription",
      "in": "body",
      "description": "Describes the repair task healthy policy to be updated.",
      "x-ms-parameter-location": "method",
      "required": true,
      "schema": {
        "$ref": "#/definitions/RepairTaskUpdateHealthPolicyDescription"
      }
    }
  },
  "x-internal-service-name": "Service Fabric",
  "x-internal-toc-name": "Invoke Infrastructure Command",
  "x-internal-split-members": [
    {
      "displayName": "Invoke Infrastructure Command",
      "relativePath": "InvokeInfrastructureCommand/InvokeInfrastructureCommand"
    }
  ],
  "x-internal-split-type": "OperationGroup"
}